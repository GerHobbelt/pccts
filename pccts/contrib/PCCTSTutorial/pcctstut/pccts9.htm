<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<title>Compiling it All</title>
<style>
<!--
PRE {color: maroon;}
CODE {color: maroon;}
-->
</style>


<meta name="Microsoft Theme" content="expeditn 001, default"><meta name="Microsoft Border" content="tb, default"></head>

<body background="../_themes/expeditn/exptextb.jpg" bgcolor="#FFFFFF" text="#000000" link="#006600" vlink="#669966" alink="#990000"><!--mstheme--><font face="book antiqua"><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="book antiqua">

<h1 align="center"><font size="7" color="#800000"><strong>Compiling it All</strong></font></h1>

<p align="center"><a href="pccts8.htm"><img src="../_derived/back_cmp_expeditn000_back.gif" width="100" height="20" border="0" alt="Back"></a><a href="../index.htm"><img src="../_derived/home_cmp_expeditn000_home.gif" width="100" height="20" border="0" alt="Home"></a><a href="index.htm"><img src="../_derived/up_cmp_expeditn000_up.gif" width="100" height="20" border="0" alt="Up"></a></p>
<!--mstheme--></font></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top">

<p align="center">&nbsp;</p>

<h2><!--mstheme--><font color="#660033">The code to be compiled<!--mstheme--></font></h2>

<p>All of the code, makefiles and VC++ 4.2 project file, are in the following zip files
(pkzip and tar.gz formats): 

<!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua"><a href="archive/recog1.zip">recog1.zip (pkzip format)</a> <!--mstheme--></font><!--msthemelist--></td></tr>
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua"><a href="archive/recog1.tgz">recog1.tgz (tar.gz format)</a> <!--mstheme--></font><!--msthemelist--></td></tr>
<!--msthemelist--></table>

<p>Here's what we have at this point:</p>

<!--mstheme--></font><pre>
#header
&lt;&lt; // any definitions that you need in the 
   //  generated files
&gt;&gt;


&lt;&lt; // scanner definitions would go here
#include &quot;dlexerbase.h&quot;
#include &quot;dlglexer.h&quot;
#include &quot;atoken.h&quot;
typedef antlrcommontoken antlrtoken;
int main(int argc, char **argv) {
    dlgfileinput in(stdin);
    dlglexer scanner(&amp;in);
    antlrtokenbuffer pipe(&amp;scanner);
    antlrtoken tok;
    scanner.settoken(&amp;tok);
    xlparser xlparser(&amp;pipe);
    xlparser.init(); // initialize
    xlparser.program(); // start first rule return 0;
} &gt;&gt;


// scanner rules

#lexclass START // Not really necessary, but
                // good commentary nonetheless

// White Space
#token &quot;[\ \t\r]&quot;     &lt;&lt;skip();&gt;&gt;
#token &quot;\n&quot;           &lt;&lt;skip(); newline();&gt;&gt;

// Comments
#token &quot;// ~[\n@]* [\n@]&quot; &lt;&lt;skip(); newline();&gt;&gt;

// Literals
#token INTLIT  &quot;[0-9]+&quot;
#token CHARLIT &quot;\' ~[] \'&quot;
#token         &quot;\&quot;&quot; &lt;&lt; // start stringlit
                       skip(); mode(string);
                    &gt;&gt;

// Keywords
#token PROGRAM   &quot;program&quot;
#token BEGIN     &quot;begin&quot;
#token END       &quot;end&quot;
#token VAR       &quot;var&quot;
#token CONSTANT  &quot;constant&quot;
#token TYPE      &quot;type&quot;
#token RECORD    &quot;record&quot;
#token ARRAY     &quot;array&quot;
#token OF        &quot;of&quot;
#token PROCEDURE &quot;procedure&quot;
#token PUT       &quot;put&quot;
#token GET       &quot;get&quot;
#token SKIPLINE  &quot;skipLine&quot;
#token NEWLINE   &quot;newLine&quot;
#token EXIT      &quot;exit&quot;
#token WHEN      &quot;when&quot;
#token RETURN    &quot;return&quot;
#token IF        &quot;if&quot;
#token THEN      &quot;then&quot;
#token ELSE      &quot;else&quot;
#token ELSIF     &quot;elsif&quot;
#token WHILE     &quot;while&quot;
#token LOOP      &quot;loop&quot;
#token AND       &quot;and&quot;
#token OR        &quot;or&quot;
#token INTEGER  &quot;Integer&quot;
#token BOOLEAN &quot;Boolean&quot; 

// Operators
#token DOT        &quot;.&quot;
#token BECOMES    &quot;:=&quot;
#token COLON      &quot;:&quot;
#token SEMI       &quot;;&quot;
#token COMMA      &quot;,&quot;
#token EQUALS     &quot;=&quot;
#token LBRACKET   &quot;\[&quot;
#token RBRACKET   &quot;\]&quot;
#token DOTDOT     &quot;..&quot;
#token LPAREN     &quot;\(&quot;
#token RPAREN     &quot;\)&quot;
#token NOT_EQUALS &quot;/=&quot;
#token LT         &quot;&lt;&quot;
#token lte        &quot;&lt;=&quot;
#token GT         &quot;&gt;&quot;
#token GTE        &quot;&gt;=&quot;
#token PLUS       &quot;\+&quot;
#token MINUS      &quot;\-&quot;
#token TIMES      &quot;\*&quot;
#token DIV        &quot;/&quot;
#token MOD        &quot;mod&quot;
#token NOT        &quot;not&quot;

// Identifiers
#token IDENT &quot;[a-zA-Z] [a-zA-Z0-9]*&quot;

// String Literal Processing
// Separate Scanner class!
#lexclass STRING
#token           &quot;\&quot;\&quot;&quot; &lt;&lt; more(); replchar('\&quot;');&gt;&gt;
#token BADSTRING &quot;\n&quot;   &lt;&lt; replchar('\0');
                           newline();
                           mode(start);
                           /* error message */
                        &gt;&gt;
#token STRINGLIT &quot;\&quot;&quot;   &lt;&lt; replchar('\0'); 
                           mode(start);
                        &gt;&gt;
#token           &quot;~[]&quot;  &lt;&lt;more();&gt;&gt;

#tokclass STRING_LITERAL {STRINGLIT BADSTRING}
#tokclass ADD_OP {PLUS MINUS}
#tokclass RELATIONAL_OP {EQUALS NOT_EQUALS GT GTE LT LTE}
#tokclass BOOLEAN_OP {AND OR}
#tokclass MULT_OP {TIMES DIV MOD}

class XLParser
{
&lt;&lt;
    // parser definitions go here
    public:
        void init() {
            antlrparser::init();
            // any specific initialization you need
            // (if none, don't override init() 
}&gt;&gt;



program
  : PROGRAM IDENT EQUALS 
        subprogramBody 
    DOT
    &quot;@&quot; // end-of-file
  ;


subprogramBody
  : (basicDecl)*
    (procedureDecl)*
    BEGIN
        statementList
    END IDENT
  ;


basicDecl
  : varDecl
  | constDecl
  | typeDecl
  ;


varDecl
  : VAR identList COLON typeName
    {BECOMES constantValue}
    SEMI
  ;


constDecl
  : CONSTANT identList COLON typeName
    BECOMES constantValue SEMI
  ;


identList
  : IDENT (COMMA IDENT)*
  ;


constantValue
  : INTLIT
  | STRING_LITERAL
  | IDENT
  ;


typeDecl
  : TYPE IDENT EQUALS
    ( arrayDecl
    | recordDecl
    )
    SEMI
  ;


arrayDecl
  : ARRAY LBRACKET integerConstant 
      DOTDOT integerConstant RBRACKET
      OF typeName
  ;

integerConstant
  : INTLIT
  | IDENT // again, a constant...
  ;


recordDecl
  : RECORD (identList COLON typeName SEMI)+ 
    END RECORD
  ;


typeName
  : IDENT
  | INTEGER
  | BOOLEAN
  ;


procedureDecl
  : PROCEDURE IDENT {formalParameters} EQUALS
        subprogramBody
    SEMI
  ;


formalParameters
  : LPAREN parameterSpec (SEMI parameterSpec)*
    RPAREN
  ;


parameterSpec
  : {VAR} identList COLON typeName
  ;

statement
  : exitStatement
  | returnStatement
  | ifStatement
  | loopStatement
  | ioStatement
  | (IDENT (LPAREN|SEMI))? procedureCallStatement
  | assignmentStatement
  ;

statementList
  : statement statementList
  | (endStatement)? endStatement statementList
  | // nothing
  ;

assignmentStatement
  : variableReference BECOMES expression SEMI
  ;


exitStatement
  : EXIT WHEN expression SEMI
  ;

procedureCallStatement
  : IDENT {actualParameters} SEMI
  ;

actualParameters
  : LPAREN { expression (COMMA expression)* } RPAREN
  ;


returnStatement
  : RETURN SEMI
  ;


ifStatement
  : IF ifPart END IF SEMI
  ;

ifPart
  : expression THEN
    statementList
    { ELSIF ifPart
    | ELSE statementList
    }
  ;

loopStatement
  : {WHILE expression} LOOP
        statementList
    END LOOP SEMI
  ;

endStatement
  : END SEMI
  ;

variableReference
  : IDENT
    ( LBRACKET expression RBRACKET
    | DOT IDENT
    )*
  ;

ioStatement
  : PUT LPAREN expression RPAREN SEMI
  | GET LPAREN variableReference RPAREN SEMI
  | SKIPLINE {LPAREN RPAREN} SEMI
  | NEWLINE {LPAREN RPAREN} SEMI
  ;


primitiveElement
  : variableReference
  | constantValue
  | LPAREN expression RPAREN
  ;


booleanNegationExpression
  : (NOT)* primitiveElement
  ;

signExpression
  : (ADD_OP)* booleanNegationExpression
  ;


multiplyingExpression
  : signExpression (MULT_OP signExpression)*
  ;

addingExpression
  : multiplyingExpression (ADD_OP multiplyingExpression)*
  ;

relationalExpression
  : addingExpression (RELATIONAL_OP addingExpression)*
  ;

expression
  : relationalExpression (BOOLEAN_OP relationalExpression)*
  ;
        </pre><!--mstheme--><font face="book antiqua">

<!--msthemeseparator--><p align="center"><img src="../_themes/expeditn/exphorsd.gif" width="300" height="10"></p>

<h2><!--mstheme--><font color="#660033">Understanding the PCCTS Compilation Process<!--mstheme--></font></h2>

<h3><!--mstheme--><font color="#996600">The Files Involved<!--mstheme--></font></h3>

<p>At some point I will expand on this a bit more to help understand how all the pieces
fit together. For now, it may be a bit sketchy...</p>

<p>The following parts are involved when building your PCCTS parser. (Assume that you save
your parser as <code>xl.g</code>:)</p>
<div align="center"><center>

<table border="1" cellpadding="9" cellspacing="1" width="100%" bordercolordark="#660000" bordercolorlight="#CC9966">
  <tr>
    <td><!--mstheme--><font face="book antiqua">xl.g<!--mstheme--></font></td>
    <td><!--mstheme--><font face="book antiqua">Your grammar source file<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">XLParser.h<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">generated by ANTLR -- contains the class declaration for the parser that
    was generated<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">XLParser.cpp<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">generated by ANTLR -- contains the definition of static class variables
    for the generated parser<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">xl.cpp<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">generated by ANTLR -- contains the definition of the rules used in the
    generated parser<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">tokens.h<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">generated by ANTLR -- contains the definition of the enumeration type used
    for token ids<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">parser.dlg<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">generated by ANTLR -- contains the scanner definitions that will be
    translated by DLG<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">DLGLexer.h, DLGLexer.cpp<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">generated by DLG -- the generated scanner<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">AParser.cpp, AParser.h<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">in the PCCTS/h directory -- base parser class<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">AToken.h, ATokPtr.h<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">in the PCCTS/h directory -- base token declarations for ANTLR<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">ATokenBuffer.cpp<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">in the PCCTS/h directory -- token buffer class<!--mstheme--></font></td>
  </tr>
  <tr>
    <td width="134"><!--mstheme--><font face="book antiqua">DLexerBase.cpp<!--mstheme--></font></td>
    <td width="350"><!--mstheme--><font face="book antiqua">in the PCCTS/h directory -- base scanner class<!--mstheme--></font></td>
  </tr>
</table>
</center></div>

<!--msthemeseparator--><p align="center"><img src="../_themes/expeditn/exphorsd.gif" width="300" height="10"></p>

<h3><!--mstheme--><font color="#996600">A Makefile<!--mstheme--></font></h3>

<p>You can use genmk (provided in the support directory of the pccts distribution) to
generate a makefile for your parser. I have provided makefiles for Visual C++ 4.2 and a
generic UNIX makefile. You should be able to modify these for your specific platform. </p>

<p>At some point I'll expand this section to describe the way the makefile works. For now,
trust it (or understand it, if you dare! Heck, it's not <i>that</i> bad...) </p>

<p>So now we try to compile/make it...</p>

<p>For our first compile, use option -w2 to ANTLR. You'll need to change this in the
makefile, or in the &quot;Custom Build Options&quot; for xl.g in Visual C++. You'll see
why in a minute... Just make sure you change it back after I make my somewhat lengthy
point. </p>

<p>Notice the warnings you get from the -w2 option like</p>

<!--mstheme--></font><pre>warning: token label has no associated
         rexpr: STRING_LITERAL        </pre><!--mstheme--><font face="book antiqua">

<p>This means one of two things: 

<!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua">STRING_LITERAL is a token class definition (which it is), or <!--mstheme--></font><!--msthemelist--></td></tr>
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua">STRING_LITERAL is not defined as a token <!--mstheme--></font><!--msthemelist--></td></tr>
<!--msthemelist--></table>

<p>This is a weak point in ANTLR (there aren't many...) You need to use the -w2 option to
see if you misspelled or just plain forgot to define a token in your scanner. Look through
the output. Notice that all of the tokens that are mentioned are token classes <i>except</i>
CONST. Hmmm...</p>

<p>Look at the definition of <code>#token CONSTANT</code>. That's the problem. We wrote
CONST where we meant CONSTANT. Change CONST to CONSTANT in the grammar and try compiling
again...</p>

<p>(As a side note, you may want to pick a suffix like _CLASS to add to token class names;
it would make finding out which reported tokens are just classes much easier.)</p>

<p>Note that ANTLR will create token definitions for tokens that are misspelled. In our
CONST case, ANTLR happily creates a</p>

<!--mstheme--></font><pre>#token CONST &quot;CONST&quot;        </pre><!--mstheme--><font face="book antiqua">

<p>definition for us... Note also that the -w2 option is also used to display ambiguities
in the grammar that are fixed by predicates that you have added. Therefore, you probably
don't want to use -w2 every time you run ANTLR, just once in a while to check for bad
tokens...</p>

<p>What happened? It looks like we have a few grammar problems. Let's look at them.</p>

<p>Remember our dicussion about adding <code>END</code> as a statement. Looks like it came
back and bit us on the but. But why?</p>

<p>The rules that are giving us trouble are rules like </p>

<!--mstheme--></font><pre>subprogramBody
  : (basicDecl)*
    (procedureDecl)*
    BEGIN
        ( statement )*
    END IDENT
  ;
        </pre><!--mstheme--><font face="book antiqua">

<p>But I thought we guarded this with predicates for the <code>END</code> statement? </p>

<p>It turns out that syntactic predicates are not &quot;hoisted&quot; like semantic
predicates are. (If I am wrong on this, please let me know -- I'm working from what
appears to be generated in the code...) A syntactic predicate just says &quot;I have a
decision to make -- <i>try</i> this alternative, then the next. That type of information
can't be relayed up to an invoking rule's &quot;if lookahead looks like...&quot; check. So
how do we handle this now? We can: 

<!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua">Use -k 2 on the command line to invoke two token lookahead <!--mstheme--></font><!--msthemelist--></td></tr>
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua">Move the syntactic predicate upward <!--mstheme--></font><!--msthemelist--></td></tr>
<!--msthemelist--></table>

<p>If we specify -k 2 on the ANTLR command-line, our problem goes away. (Note, if you try
this, remove the syntactic predicates from the grammar.) I'll stick with the predicates
because it's a more complex example and you may have to do something like this with
another project.</p>

<p>If we just move the predicates up, it may work, but now we have extra predicates all
over the grammar. Our goal was to fix the lookahead problem in a single place. So let's
create a single place. Instead of using <code>(statement)*</code> to represent a statement
list, we'll create a rule called statementList:</p>

<!--mstheme--></font><pre>statementList
  : statementList statement
  | // nothing
  ;
        </pre><!--mstheme--><font face="book antiqua">

<p>Some of you may be saying &quot;but...&quot; but I'll cut you off because I've spent
too much time in yacc-land recently. Silly me coded the rule this way. Yup,
left-recursion, an LL no-no, but I'm not too proud to admit I make these mistakes
sometimes. ANTLR is very nice about it and reports</p>

<!--mstheme--></font><pre>error: infinite left-recursion to rule statementList
       from rule statementList        </pre><!--mstheme--><font face="book antiqua">

<p>So I shake my head in disbelief that I typed it (10 minutes before writing this) and
change it to</p>

<!--mstheme--></font><pre>statementList
  : statement statementList
  | // nothing
  ;
        </pre><!--mstheme--><font face="book antiqua">

<p>and compile again...</p>

<p>Better; we're still getting the message about the <code>END</code> statement. But now
the conflict is isolated to one spot. The conflict is that we can choose statement when we
see &quot;END&quot; in the input stream, or say &quot;we're done with the
statementList&quot; because it can be followed by &quot;END.&quot; It is in this rule that
we need to make the decision. So...</p>

<p>...we <i>could</i> put a syntactic predicate around the call to <code>statement</code>.
But that would be incrediby wasteful. A &quot;guess&quot; parse would take place for every
statement. Not good. But we still need to make a guess at this point. So what do we do? </p>

<p>We move the <code>endStatement</code> out of the statement rule and into <code>statementList</code>:</p>

<!--mstheme--></font><pre>statementList
  : statement statementList
  | (endStatement)? endStatement statementList
  | // nothing
  ;
        </pre><!--mstheme--><font face="book antiqua">

<p>And now, the conflict disappears. We have applied the syntactic predicate to the point
of the conflict.</p>

<p>After we compile this, we have one last conflict. In <code>primitiveElement</code> we
have a choice between <code>constantValue</code> and <code>variableReference</code> <i>which
could both be an <code>IDENT</i></code>! Why do we have <code>IDENT</code> in both places?
Because the <i>semantics</i>, (the <i>meanings</i>) of the references are different. This
should be a hint that we will need a <i>semantic predicate</i> to properly resolve this
(without mangling the grammar.) The semantic predicate we will be using will say &quot;if
the IDENT is a constant, match <code>constantValue</code>; if it's not, match <code>variableReference</code>.&quot;
That type of check requires a symbol table, which we don't have yet. So, we leave this
conflict in the grammar. This will produce code for <code>primitiveElement</code> like</p>

<!--mstheme--></font><pre>primitiveElement() {
    if next token is IDENT || STRING_LITERAL
                           || INTLIT
        call constantValue
    else if next token is IDENT
        call variableReference
    else if next token is LPAREN
        match LPAREN
        call expression
        match RPAREN
    else
        report error
        </pre><!--mstheme--><font face="book antiqua">

<p>which means that and IDENT that could come in a <code>primitiveElement</code> context
will be matched through <code>constantValue</code>. This is a bit of a problem, because
things like a[4] cannot be matched, as they are handled by <code>variableReference</code>.
Since <code>constantValue</code> only uses a single IDENT by itself, we won't lose
anything by swapping it with <code>variableReference</code>, so swap 'em! </p>

<!--msthemeseparator--><p align="center"><img src="../_themes/expeditn/exphorsd.gif" width="300" height="10"></p>

<h3><!--mstheme--><font color="#996600">Building it for Real<!--mstheme--></font></h3>

<p>OK. At this point, you should have some code that looks like the code linked below:</p>

<p>All of the code, makefiles and VC++ 4.2 project file, are in the following zip files
(pkzip and tar.gz formats): 

<!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua"><a href="archive/recog2.zip">recog2.zip (pkzip format)</a> <!--mstheme--></font><!--msthemelist--></td></tr>
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua"><a href="archive/recog2.tgz">recog2.tgz (tar.gz format)</a> <!--mstheme--></font><!--msthemelist--></td></tr>
<!--msthemelist--></table>

<p>I may have mucked something up, so <i>just</i> in case, get these. I know they are
correct... Build them and things should be clean (with the exception of the conflict in <code>primitiveElement</code>.)
Now, you can try some simple tests:</p>

<p>The sample code we will use to test the XL compiler is in the following zip files
(pkzip and tar.gz formats): 

<!--msthemelist--><table border="0" cellpadding="0" cellspacing="0" width="100%">
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua"><a href="archive/tests.zip">tests1.zip (pkzip format)</a> <!--mstheme--></font><!--msthemelist--></td></tr>
  <!--msthemelist--><tr><td valign="baseline" width="42"><img src="../_themes/expeditn/expbul1d.gif" width="20" height="20" hspace="11"></td><td valign="top" width="100%"><!--mstheme--><font face="book antiqua"><a href="archive/tests.tgz">tests1.tgz (tar.gz format)</a> <!--mstheme--></font><!--msthemelist--></td></tr>
<!--msthemelist--></table>

<p>Get these files, unzip them and run them through the xl parser. For example:</p>

<!--mstheme--></font><pre> xl &lt; sample1.xl        </pre><!--mstheme--><font face="book antiqua">

<!--msthemeseparator--><p align="center"><img src="../_themes/expeditn/exphorsd.gif" width="300" height="10"></p>

<h3><!--mstheme--><font color="#996600">Wrapup for now<!--mstheme--></font></h3>

<p>This wraps up the recognizer section of this tutorial. I hope it's been helpful at some
level for you. As always, please let me know your comments (good or bad -- helps the ego
ya know) at <a href="mailto:thetick@scruz.net">thetick@scruz.net</a>. </p>

<p align="left">Unfortunately, I've pretty much stopped work on this, other than prettying
it up and adding navigation aids.&nbsp; Terence Parr and I are working on a Tutorial book
for ANTLR 2.0, the new, Java version of PCCTS.&nbsp; Stay tuned to <a href="news:comp.compilers.tools.pccts">comp.compilers.tools.pccts</a>&nbsp; for
information! 
<!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><!--mstheme--><font face="book antiqua">

<p align="center"><a href="pccts8.htm"><img src="../_derived/back_cmp_expeditn000_back.gif" width="100" height="20" border="0" alt="Back"></a><a href="../index.htm"><img src="../_derived/home_cmp_expeditn000_home.gif" width="100" height="20" border="0" alt="Home"></a><a href="index.htm"><img src="../_derived/up_cmp_expeditn000_up.gif" width="100" height="20" border="0" alt="Up"></a></p>

<p align="center">This page was last updated on 09/08/97.</p>
<!--mstheme--></font></td></tr><!--msnavigation--></table><!--mstheme--></font></body>
</html>
