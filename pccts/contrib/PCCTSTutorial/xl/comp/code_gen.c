// File: code_gen.c -- code generator for xl compiler
// Author: Scott Stanchfield
//  
//   This module contains code that will traverse an Abstract Syntax Tree (AST) and generate code to be executed by
//   the "go" routine.
//

// Include headers
#include <fcntl.h>      // File operations
#include <stdio.h>      // I/O operations
#include <stdlib.h>     // For access to "exit"
#include "xl.pccts.h"   // Definitions used in the xl compiler
#include "antlr.h"      // PCCTS definitions 
#include "tokens.h"     // Token definitions (generated by ANTLR)
#include <assert.h>     // Assertions
#include "opcodes.h"    // Definitions of the operation codes that represent the "go" machine

// Define "boolean" constants
#define TRUE            1
#define FALSE           0
#define BOOL            int

// Define label aliases
//    These definitions will be used whenever a reference to a label is needed.  Each label variable
//       (label1 and label2) is actually a pointer to a list of saved instructions.  When an instruction is
//       generated using the "write_branch" routine, the instruction is saved and a pointer to it is added to
//       the label list that was passed in.  When the label address is finally known, the label list is 
//       traversed and the instructions' operands are updated.  
//    The advantage to this processing, is that code with no branching will only require one pass to generate, and
//       code with small branch distances will only re-traverse short sections to generate code.  It also saves
//       the need for a jump table when generating code.  (The complexity of each is probably a toss up -- I just 
//       think this method is clearer when its actually used in the gen_code function.)
#define true_label      &label1
#define false_label     &label1
#define else_label      &label1
#define continue_label  &label2
 
 
// CODE is a structure that will be used to save instructions that are generated when an unknown
//   label is waiting for its definition.  
typedef struct _code
{
   int            opcode;   // The operation code
   int            num_ops;  // The number of operands
   int            op1;      // The operands
   int            op2;
   struct _code  *next;     // Points to the next saved instruction
} CODE;


// LABEL is a structure that will be used to save references to all instructions that 
//   reference a given label.
typedef struct _label
{
   CODE          *instr;   // Pointer to the CODE structure that contains the saved instruction
   struct _label *next;    // 
} LABEL;

// The held_code list will contain a list of instructions starting with an unresolved label.
//   all instructions after an unresolved label will be saved until the label's address is
//   finally known.  When all labels in the held_code list are resolved, the code will
//   be written to the object file.
CODE *held_code             = NULL;  // The start of the list of held operations
CODE *end_of_held_code      = NULL;  // The end of the list of held operations
int label_count             = 0;     // How many unresolved labels remain

int mem_loc                 = 0;     // Current relative memory address of code
BOOL first_body             = TRUE;  // This flag lets us know if we are defining a program (the first
                                     //   body section to be defined) or a procedure
int file;                            // The object file where code will be written


// write_instr_to_fileX -- write a given operation to the object file
//   the X in the name above varies from 0 to 2, depending on the number of arguments the
//   operator takes.  The integer values of the code will be written to the object file.
//   WRITE_INT_TO_FILE is defined to make the procedures smaller
#define WRITE_INT_TO_FILE(op)    if (!write(file, &op, sizeof(int)))           \
                                 {                                             \
                                    printf("Error writing to object file\n");  \
                                    exit(12);                                  \
                                }                                             
                                
void write_instr_to_file0(int opcode)
{ WRITE_INT_TO_FILE(opcode); }
   
void write_instr_to_file1(int opcode, int op1)
{  WRITE_INT_TO_FILE(opcode); WRITE_INT_TO_FILE(op1); }
   
void write_instr_to_file2(int opcode, int op1, int op2)
{  WRITE_INT_TO_FILE(opcode); WRITE_INT_TO_FILE(op1); WRITE_INT_TO_FILE(op2);   }
   
   
// write_held_instr_to_file -- write a CODE stuct that has been saved in the held_code list to
//    the object file
void write_held_instr_to_file(CODE *instr)
{
   // Write out the number of operands that the operation has
   if (instr->num_ops == 0)
      write_instr_to_file0(instr->opcode);
   else if (instr->num_ops == 1)
      write_instr_to_file1(instr->opcode, instr->op1);
   else  // instr->num_ops == 2
      write_instr_to_file2(instr->opcode, instr->op1, instr->op2);
}
   
// write_instrX -- generate code for the given instruction
//   If there are no unresolved labels, these routines will write the code
//   directly to the object file.  Otherwise, they will save the code on the held_code list
#define MAKE_NEW_CODE_NODE       if (!end_of_held_code)                                                 \
                                    end_of_held_code = held_code = malloc(sizeof(CODE));                \
                                 else                                                                   \
                                    end_of_held_code = end_of_held_code->next = malloc(sizeof(CODE));

void write_instr2(int opcode, int op1, int op2)
{
   // if no held code, just write the code to the file
   if (label_count == 0)   
      write_instr_to_file2(opcode, op1, op2);
      
   // Otherwise, hold the code for now
   else
   {
      MAKE_NEW_CODE_NODE;         
      end_of_held_code->opcode  = opcode;
      end_of_held_code->op1     = op1;
      end_of_held_code->op2     = op2;
      end_of_held_code->num_ops = 2; 
      end_of_held_code->next    = NULL;
   }
   mem_loc += 3;  // Move our memory counter past the new code
}
   
void write_instr1(int opcode, int op1)
{
   // if no held code, just write the code to the file
   if (label_count == 0)   
      write_instr_to_file1(opcode, op1);
       
   // Otherwise, hold the code for now
   else
   {
      MAKE_NEW_CODE_NODE;
      end_of_held_code->opcode  = opcode;
      end_of_held_code->op1     = op1;
      end_of_held_code->num_ops = 1;
      end_of_held_code->next    = NULL;
   }
   mem_loc += 2;  // Move past the new code
}
   
void write_instr0(int opcode)
{
   // if no held code, just write the code to the file
   if (label_count == 0)   
      write_instr_to_file0(opcode);
         
   // Otherwise, hold the code for now
   else
   {
      MAKE_NEW_CODE_NODE;
      end_of_held_code->opcode  = opcode;
      end_of_held_code->num_ops = 0;
      end_of_held_code->next    = NULL;
   }
   mem_loc++;  // Move past the new code
}
   
   
// write_branch -- generate code that references an undefined label
//   write the new instruction to the held code list
//   add a pointer to the new instruction to the label list (for update later)
void write_branch(int opcode, LABEL **label)
{
   LABEL *temp;
   if (!*label)
      label_count++;
   // write the branch code as a placeholder for now
   write_instr1(opcode, mem_loc);
      
   // Remember what we need to update -- add pointer to the node to the label list
   temp  = malloc(sizeof(LABEL));
   temp->next = *label;
   temp->instr = end_of_held_code;  // capture the code we just generated
   *label = temp;
}
   
// Resolve the value of a previously unknown label   
//   for each instruction pointed to in the label list
//     define the now-known address of the label
//   if there are no more unresolved labels
//     write all held instructions to the object file
void set_label(LABEL **label)
{
   LABEL *p, *next_p; // For walking through the label list
   CODE  *c, *next_c; // For walking through the code list
      
   // set the addresses of all previous refs to this label
   for (p=*label; p; p = next_p)  // For each instruction pointed to in the label list
   {
      p->instr->op1 = mem_loc - p->instr->op1 - 2;    // set the address for the label
      next_p = p->next;                               // get ready for the next label node
      free(p);                                        // kill the current label node
   }
   *label = NULL; // blank out the label list
      
   label_count--; // we now have one less unresolved label
      
   // If all labels have been resolved, write them out
   if (label_count == 0)
   {
      for(c = held_code; c; c = next_c)      // For each instruction in the held code list
      {
         write_held_instr_to_file(c);        //    Write out the instruction
         next_c = c->next;                   //    Move to the next instruction
         free(c);                            //    kill the current instruction
      }
      end_of_held_code = held_code = NULL;   // Blank out the held code list
   }
}


// gen_code -- the main code generation routine
//    examine the current node and generate code appropriately for the node
//       (this may involve recursively calling gen_code...)
// Note on AST descriptions.  I will use several comments like "The AST looks like: " followed by an
//    AST decription in lisp-like format.  For example, if a description is
//          (Index (Ref (VAR)) (Value (INTLIT)))
//    then the root of the node is the token "Index", the first child is (Ref (VAR)) and the sibling of the child is
//   (Value (INTLIT)).  In this example, if we wanted to access the variable that is being indexed (the VAR node), we use
//          zzchild(zzchild(tree))
//   and the index value (the INTLIT node) would be
//          zzchild(zzsibling(zzchild(tree)))
//   If this is unclear, meditate for a while and it will come to you...  (See PCCTS docs for some other examples...)
void gen_code(AST *tree, int level, LABEL **loop_label)
{
   AST *child = zzchild(tree);         // What is the first child of this AST node
   int x=0;                            // Misc integer holder (it will be described as it's used)
   int displacement;                   // Used when determining variable displacements
   LABEL *label1=NULL, *label2=NULL;   // Label list heads
    
   // Look at the current node -- what token represents it?
   switch (TokenOf(tree))
   {
      
      case File:
         // AST node:  (File <defs>* <program>)
         
         // Move past the type definitions set up by the compiler -- no code is generated for these
         while(TokenOf(child) != Program)  // Until we reach the program child...
             child = zzsibling(child);     //    move to the next child
             
         // Generate the code for the program
         gen_code(child, level, loop_label); 
         break;
         
         
      case Program:
         // AST node:  (Program <body>)
          
         // Write a program instruction to set aside enough memory for the global variables
         write_instr1(i_program, SizeOf(tree));
         
         // Generate code for the body of the program (this includes var and procedure decls)
         //   Note that level is increased!
         gen_code(child, (level+1), loop_label);
         break;
         
         
      case Procedure:
         // AST node: (Procedure (Parms <parmdecl>*) <body>)
         
         // Get the current code location for this procedure -- that's its displacement
         DispOf(tree) = mem_loc;
          
         // Set up displacements for the parameters -- note that we have to work backwards
         //   The total size of the parameters was stored when they were parsed
         displacement = 0;
         child = zzchild(child);    // Start with the first parameter in (Parms <parmdecl>*)
         while(child)               // For each parameter
         {
             // Set the displacement -- it's negative!
             DispOf(zzchild(child)) = displacement - SizeOf(zzchild(tree));     
             displacement += SizeOf(zzchild(child));  
             child = zzsibling(child);                // Move to the next parameter
         }
         
         // Write a procedure instruction to set aside memory for the procedure's variables
         write_instr1(i_procedure, SizeOf(tree));
         
         // Generate code for the statements and variable declarations in the procedure
         gen_code(zzsibling(zzchild(tree)), (level+1), loop_label);
         
         // generate a return from the procedure
         write_instr0(i_return);
         break;
         
      case Return:
         // AST node: (Return)
         // generate a return from the procedure
         write_instr0(i_return);
         break;
         
      case ProcedureCall:
         // AST node:  (ProcedureCall (Ref <procedure>) (Parms <expr>*))
         
         // push parameters on the stack
         child = zzchild(zzsibling(child));  // Starting with the first expression in (Parms <expr>*)
         displacement = 0;                   // Keep track of how much we need to pop off the stack afterwards
         
         while(child)   // For each parameter expression
         {
             gen_code(child, level, loop_label);   // Evaluate the expression
             displacement += SizeOf(child);        // Keep track of how big it is
             child = zzsibling(child);             // Go to the next parameter expression
         }
         
         // call the procedure
         write_instr2(i_proc_call, level-LevelOf(zzchild(zzchild(tree))), DispOf(zzchild(zzchild(tree)))-mem_loc-3); 
         write_instr1(i_pop, displacement);  // pop off the parameters            
         break;
         
      case Body:
         // AST node: (Body <defs>* <subprogs>* <stmnts>*)
         
         // If this is the program expansion, there is no static or dynamic link and return address 
         //    on the stack -- displacement = 0
         if (first_body)
         {
            displacement   = 0;
            first_body     = FALSE;
         }
         
         // Otherwise, we need to get start variables around the links and return address -- displacement = 3
         else 
            displacement = 3;
             
         // Set up displacements, and inits if needed -- for each VAR, CONST or TYPE definition
         while(TokenOf(child) == Define && 
               (TokenOf(zzchild(child)) == VAR || TokenOf(zzchild(child)) == CONST || TokenOf(zzchild(child)) == TYPE))
         {
            // If it's a variable, we need to set displacements and initialize (if necessary)
            if (TokenOf(zzchild(child)) == VAR)
            {
               DispOf(zzchild(child)) = displacement;                           // Capture it's displacement
               if (Init(zzchild(child)))                                        // Set up init if needed
               {
                  write_instr1(i_localvar, displacement);                       // Get its address
                  write_instr1(i_constant, atoi(NameOf(Init(zzchild(child))))); // Set constant for init value
                  write_instr0(i_simple_assign);                                // Assign it
               }
               displacement += SizeOf(zzchild(child));                          // Get the next displacement
            }
            child = zzsibling(child);         // on to the next definition
         }

         // Now make the program branch around any subprogram decls (if there are any)
         if (TokenOf(child) == Define)
         {
            write_branch(i_goto, continue_label);   // Generate a "goto" to jump around procedure decls
               
            // Generate code for subroutines
            while(TokenOf(child) == Define)                 //  For each procedure decl
            {
               gen_code(zzchild(child), level, loop_label); //          generate code for the procedure
               child = zzsibling(child);                    //          go to the next procedure
            }
            
            // Add the label for the branch-around
            set_label(continue_label);
         }

         // Now process the rest of the declaration for this program/procedure
         while(child)                              // For each statement...
         {
            gen_code(child, level, loop_label);    //    Generate code for the statement
            child = zzsibling(child);              //    go to the next statement
         }
         break;
           
           
      case If:
         // AST node: (If <expr> (ThenPart <statement>*) (ElsePart <statement>*))
         
         // Evaluate if condition
         gen_code(child, level, loop_label);
           
         // If the expression evaluates FALSE, jump to the else part
         write_branch(i_branch_false, else_label);
         
         // Otherwise, execute the "then part" code generated below
         gen_code(zzsibling(child), level, loop_label);  // Generate the "then" code
         
         // If there is an "else part", jump around it
         if (zzsibling(zzsibling(child)))
            write_branch(i_goto, continue_label);  
            
         // Label the "else part" 
         set_label(else_label);                    // Label the "else part" of the code
         
         // If there is code for the else part, generate it and label the end of it
         if (zzsibling(zzsibling(child)))          
         {
            gen_code(zzsibling(zzsibling(child)), level, loop_label);  
            set_label(continue_label);
         }
         break;
            
            
      case ThenPart:
      case ElsePart:
         // AST node: (ThenPart <statement>*)  or (ElsePart <statement>*)
         
         while(child)                           // For each statement
         {
            gen_code(child, level, loop_label); //    generate code for the statement
            child = zzsibling(child);           //    go to the next statement
         }
         break;
            
            
      case Exit:
         // AST node:  (Exit [<expr>])
         // if there is an exit condition, evaluate it, then branch if it's true
         if (child)
         {
            gen_code(child, level, loop_label);  // evaluate the exit condition
            write_branch(i_branch_true, loop_label);   // set up the branch if it evals true
         }
         
         // Otherwise, unconditionally exit the loop
         else
            write_branch(i_goto, loop_label);
         break;


      case Loop:
         // AST node: (Loop [(While <expr>)] <statement>*)
         
         // remember where the loop starts, so we can branch back here at the end of the loop
         x = mem_loc;
         
         // If there is a "while" condition, evaluate it and skip the loop if it's false
         if (TokenOf(child) == While)
         {
            gen_code(zzchild(child), level, loop_label);        // evaluate the "while" condition
            write_branch(i_branch_false, continue_label);       // if false, skip loop
            child = zzsibling(child);                           // move to the statements part of the loop
         }
         
         // generate code for statements in the loop
         while(child)                                 // for each statement in the loop
         {
            gen_code(child, level, continue_label);   //    pass continue label so we can update addr if it's an exit
            child = zzsibling(child);                 //    go to the next statement
         }
         
         // Generate a "goto" back to the top of the loop.  Note that the -2 is needed because we will be 
         //   branching relative to the NEXT instruction's address
         write_instr1(i_goto, x - mem_loc - 2);  
         
         // Resolve any references to "getting out of the loop"
         set_label(continue_label);
         break;


      case Op:
         // AST node: (Op  <operand1> [<operand2>])
         //    This needs to br broken down by the NAME of the operand
         
         // If not an "and" or an "or", generate the child expressions first
         //   "And" and "or" perform short-circuiting, so we may not want to evaluate the  
         //   second operand yet...
         if ((NameOf(tree)[0] != 'a') && (NameOf(tree)[0] != 'o'))
         {
            gen_code(child, level, loop_label);    // Evaluate the left side of the expression
            if (zzsibling(child))                  // if there is a right side, evaluate it
               gen_code(zzsibling(child), level, loop_label);
         }
              
         // Generate code based on the actual operator
         switch(NameOf(tree)[0])
         {
            case '+':               
               // AST node: (+ <expr1> <expr2>)
               write_instr0(i_add); // generate code to add the top two things on the stack
               break;
                  
            case '-': 
               // AST node: (- <expr1> <expr2>)  or  (- <expr1>)
               if (zzsibling(child))   // if this is a BINARY '-' operator
                  write_instr0(i_sub); //    generate code to subtract the top of the stack from the next on the stack
               else                    // otherwise
                  write_instr0(i_neg); //    generate code to negate the top element on the stack
               break;
                  
            case '*':  
               // AST node: (* <expr1> <expr2>)            
               write_instr0(i_mult);  // generate code to multiply the top two elements on stack
               break;
                  
            case '/':  
               // AST node: (/ <expr1> <expr2>)  or (/= <expr1> <expr2>)
               if (NameOf(tree)[1] == '=')   // if this is a "/=" operator
                  write_instr0(i_ne);        //    generate code to test NON equality
               else                          // otherwise
                  write_instr0(i_div);       //    generate coed to divide second-from-top element by top element of stack
               break;
                  
            case '=': 
               // AST node: (= <expr1> <expr2>)
               write_instr0(i_eq); // generate code to check if the top two elements on the stack are equal
               break;
                  
            case '<':     
               // AST node: (< <expr1> <expr2>)  or  (<= <expr1> <expr2>)
               if (NameOf(tree)[1] == '=')   // if the operator is "<="
                  write_instr0(i_le);        //    generate code to check if second-from-top is <= top element on stack
               else                          // otherwise
                  write_instr0(i_lt);        //    generate code to check for strictly less than
               break;
                  
            case '>':  
               // AST node: (> <expr1> <expr2>)  or  (>= <expr1> <expr2>)
               if (NameOf(tree)[1] == '=')   // if the operator is ">="
                  write_instr0(i_ge);        //    generate code to check if second-from-top is >= top element on stack
               else                          // otherwise
                  write_instr0(i_gt);        //    generate code to check for strictly greater than
               break;
                  
            case 'n': 
               // AST node: (not <expr1>)
               write_instr0(i_not);  // generate code to boolean "not" the top element on the stack
               break;
                  
            case 'm': 
               // AST node: (mod <expr1> <expr2>)
               write_instr0(i_mod); // generate code to produce second-from-top mod top of stack
               break;
                  
            case 'a':  // "and" operator
               // AST node: (and <expr1> <expr2>)
               gen_code(child, level,loop_label);            // evaluate the left side of the "and"
               write_branch(i_branch_false, false_label);    // if left side is false, short circuit -- expr is false
               
               gen_code(zzsibling(child), level,loop_label); // otherwise, evaluate the right side 
               write_branch(i_branch_false, false_label);    // if it's false, expr is false
               write_instr1(i_constant, TRUE);               // otherwise, it's all true
               write_branch(i_goto, continue_label);         // goto rest of code
               
               set_label(false_label);                       // the false cases all end here
               write_instr1(i_constant, FALSE);              // set the result to FALSE
               set_label(continue_label);                    // continue from here
               break;
                  
                  
            case 'o': // "or" operator
               // AST node: (or <expr1> <expr2>)
               gen_code(child, level, loop_label);              // evaluate the left side of the "or"
               write_branch(i_branch_true, true_label);         // if left side is true, short circuit -- expr is true 
               
               gen_code(zzsibling(child), level,loop_label);    // otherwise, evaluate the right side
               write_branch(i_branch_true, true_label);         // if it's true, expr is true
               write_instr1(i_constant, FALSE);                 // otherwise, it's all false
               write_branch(i_goto, continue_label);            // goto rest of code
               
               set_label(true_label);                           // the true cases all end here
               write_instr1(i_constant, TRUE);                  // set the result to true
               set_label(continue_label);                       // continue from here
               break;
                  
                  
            default:                  
               // AST node: <<** unknown **>>
               printf("error %s\n", NameOf(tree));
               break;
         }
         break;
            
      case Assign:
         // AST node: (Assign (Ref (VAR)) <expr>)        or             (Assign (Value (Ref (VAR))) <expr>)
         //                   ^^^^^^^^^^^ normal value reference                ^^^^^^^^^^^^^^^^^^^ "var" reference
         // find level, disp and size of child
         
         gen_code(child, level, loop_label);  // gen the addr of the thing being assigned
                                              // Note: if this is a "var" parameter in a procedure, an extra "Value"
                                              //       node will be present to treat the variable as holding the 
                                              //       ADDRESS of the variable to be updated
                                              
         // Generate code for the expression being assiged to the variable                                              
         gen_code(zzsibling(child), level,loop_label);
         
         if (SizeOf(child) == 1)             // If only one int long, use simple assign
            write_instr0(i_simple_assign);
         else                                // otherwise, use normal assign
            write_instr1(i_assign, SizeOf(child));
         break;
         
         
      case Ref:
         // AST node: (Ref (VAR))  -- get the address of a variable
         
         if ((level-LevelOf(child)) == 0)             // If variable is at current level, use localvar
            write_instr1(i_localvar, DispOf(child));
         else                                         // else use normal addressing
            write_instr2(i_variable, (level-LevelOf(child)), DispOf(child));
         break;
            
            
      case Value:
         // AST node: (Value <address>)
         
         // Evaluate the child to get the address we want to get the value
         gen_code(child, level, loop_label);
         
         // If we are dealing with a 1-integer variable, do a simple value
         if (SizeOf(child) == 1)
            write_instr0(i_simple_value);
            
         // Otherwise, set up a value instruction to get the entire variable
         else
            write_instr1(i_value, SizeOf(child));
         break;
            
      case Index:
         // AST node: (Index <base var> <index>)
         
         // Generate code to get the address of the base variable
         gen_code(child, level,loop_label);
         
         // Generate code to deterimine the value of the index
         gen_code(zzsibling(child), level, loop_label);
         
         // Normalize to the bounds... (a bit higher-level) and check bounds
         // push lower bound on the stack
         gen_code(zzchild(zzchild(zzchild(TypeOf(child)))), level, loop_label);
         // push upper bound on the stack
         gen_code(zzchild(zzsibling(zzchild(zzchild(TypeOf(child))))), level, loop_label);
         write_instr0(i_bounds);
         
         // If array elements are > 1 unit, multiply by their size
         if (SizeOf(TypeOf(TypeOf(child))) != 1)
         {
            write_instr1(i_constant, SizeOf(TypeOf(TypeOf(child))));
            write_instr0(i_mult);
         }
         
         // Add the index displacement to the base address of variable
         write_instr0(i_add);
         break;

      case Field:
         // AST node: (Field <base variable> <field ref>)
         
         // Generate code to determine the base address of the record
         gen_code(child, level,loop_label);
         
         // If the field referenced is not the first in the record...
         if (DispOf(zzchild(zzsibling(child))) != 0)
         {
            // Stick the displacement of the field on the stack
            write_instr1(i_constant, DispOf(zzchild(zzsibling(child))));
            // Add the displacement to the base address of the variable
            write_instr0(i_add);
         }
         break;

      case Get:
         // AST node: (Get <variable addr>)
         
         // Generate code to get the address of the variable
         gen_code(child, level, loop_label);
         
         // Generate the "get" instruction to input the integer into that address
         write_instr0(i_get_int);
         break;
            
            
      case Put:
         // AST node: (Put <thing>)
         
         // If the <thing> is a string literal, have some fun...
         if (TokenOf(child) == STRINGLIT)
         {
            // Write the put string instruction
            write_instr1(i_put_string, SizeOf(child));
            
            // Insert the string literal into the code
            for(x=0; x < SizeOf(child); x++)
               write_instr0((int)(NameOf(child)[x]));
         }
         
         // otherwise, it's an integer
         else
         {
            gen_code(child, level, loop_label);    // get the value of the integer
            write_instr0(i_put_int);               // generate the "put"
         }
         break;
            
            
      case INTLIT:
         // AST Node: (INTLIT)
         
         // Generate a constant in the code for the value
         write_instr1(i_constant, atoi(NameOf(tree)));
         break;
            
            
      case NewLine:
         // AST node: (NewLine)
         write_instr0(i_new_line);  // generate a new line instruction
         break;
            
            
      case SkipLine:
         // AST node: (SkipLine)
         write_instr0(i_skip_line); // generate an instruction to skip a line
         break;
            
            
      case PassAddr:
         // AST node: (PassAddr <thing>)
         // This is a dummy node.  It is used when a parameter is being passed to a procedure in place
         //    of a "var" formal parameter.  The normal "value" node is changed to a "PassAddr" node to
         //    tell this code generator to just pass the address of the variable
         gen_code(child, level, loop_label);
         break;
            
            
      default: 
         // AST node: <<** unknown **>>
         printf("%s not yet handled\n", zztokens[TokenOf(tree)]);
         break;
   }
}


// generate_code -- the base code generation routine -- hides a few details from the parser
void generate_code(AST *tree)
{
   // Open the object code file
   if ((file = open(file_name, O_WRONLY | O_TRUNC | O_CREAT)) < 0)
      printf("Error opening object file\n");
   else
   {
      gen_code(tree, 0, NULL);   // Generate all the code
      write_instr0(i_halt);      // Write a "halt" instruction
      close(file);               // Close the object code file
   }         
}