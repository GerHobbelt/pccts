/* Main function for dlg version
 *
 * SOFTWARE RIGHTS
 *
 * We reserve no LEGAL rights to the Purdue Compiler Construction Tool
 * Set (PCCTS) -- PCCTS is in the public domain.  An individual or
 * company may do whatever they wish with source code distributed with
 * PCCTS or the code generated by PCCTS, including the incorporation of
 * PCCTS, or its output, into commerical software.
 *
 * We encourage users to develop software with PCCTS.  However, we do ask
 * that credit is given to us for developing PCCTS.  By "credit",
 * we mean that if you incorporate our source code into one of your
 * programs (commercial product, research project, or otherwise) that you
 * acknowledge this fact somewhere in the documentation, research report,
 * etc...  If you like PCCTS and have developed a nice tool with the
 * output, please mention that you developed it using PCCTS.  In
 * addition, we ask that this header remain intact in our source code.
 * As long as these guidelines are kept, we expect to continue enhancing
 * this system and expect to make other tools available as they are
 * completed.
 *
 * DLG 1.33
 * Will Cohen
 * With mods by Terence Parr; AHPCRC, University of Minnesota
 * 1989-2001
 */

#include <stdio.h>

#include "pcctscfg.h"
#include "stdpccts.h"

#ifdef PCCTS_USE_STDARG
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#if defined(_MSC_VER)
#define STRDUP _strdup /* [i_a] because __STDC__ has been defined; this one must be used... */
#else
#define STRDUP strdup 
#endif

char	program[] = "dlg";
char	version[] = "1.33MR33";					/* MRXXX */
int     Save_argc = 0;                                                  
char ** Save_argv = 0;                                                  
int	numfiles = 0;
char	*file_str[2] = {NULL, NULL};
char	*mode_file = "mode.h";
char	*class_name = DEFAULT_CLASSNAME;
char	*OutputDirectory = TopDirectory;

/* Option variables */
int comp_level = 0;
int interactive = FALSE;
int case_insensitive = FALSE;
int warn_ambig = FALSE;
int gen_cpp = FALSE;

#ifdef __USE_PROTOS
static int ci_strequ(char *a,char *b)
#else
static int ci_strequ(a,b)
  char  *a;
  char  *b;
#endif
{
  for ( ;*a != 0 && *b != 0; a++, b++) {
    if (toupper(*a) != toupper(*b)) return 0;
  }
  return (*a == *b);
}

/* Option List Stuff */
#ifdef __USE_PROTOS
void p_comp0(void)		{comp_level = 0;}
void p_comp1(void)		{comp_level = 1;}
void p_comp2(void)		{comp_level = 2;}
void p_stdio(void)		{ file_str[numfiles++] = NULL;}
void p_file(char *s) 	{ file_str[numfiles++] = s;}
void p_cl_name(char *s, char *t)
	{
		if ( gen_cpp ) {
			class_name = t;
		}
		else {
			warning("-cl only valid in C++ mode; -cl ignored...",0);
		}
	}
void p_mode_file(char *s, char *t){mode_file=t;}
void p_outdir(char *s,char *t) {OutputDirectory=t;}
void p_ansi(void)		{gen_ansi = TRUE;}
void p_interactive(void)	{interactive = TRUE;}
void p_case_s(void)		{ case_insensitive = FALSE; }
void p_case_i(void)		{ case_insensitive = TRUE; }
void p_warn_ambig(void)	{ warn_ambig = TRUE; }
void p_cpp(void)		{ gen_cpp = TRUE; }
#else
void p_comp0()		{comp_level = 0;}
void p_comp1()		{comp_level = 1;}
void p_comp2()		{comp_level = 2;}
void p_stdio()		{ file_str[numfiles++] = NULL;}
void p_file(s) char *s;	{ file_str[numfiles++] = s;}
void p_cl_name(s,t)
	char *s, *t;
	{
		if ( gen_cpp ) {
			class_name = t;
		}
		else {
			warning("-cl only valid in C++ mode; -cl ignored...",0);
		}
	}
void p_mode_file(s,t) char *s,*t;{mode_file=t;}
void p_outdir(s,t) char *s,*t;{OutputDirectory=t;}
void p_ansi()		{gen_ansi = TRUE;}
void p_interactive()	{interactive = TRUE;}
void p_case_s()		{ case_insensitive = FALSE; }
void p_case_i()		{ case_insensitive = TRUE; }
void p_warn_ambig()	{ warn_ambig = TRUE; }
void p_cpp()		{ gen_cpp = TRUE; }
#endif



void 
#ifdef __USE_PROTOS
p_errors_borland_style(void)
#else
p_errors_borland_style()
char *s;
char *t;
#endif
{                     
  printf_stderr_cfg(ERR_DIAG_FMT_BCC, NULL, -1, NULL);
}

void 
#ifdef __USE_PROTOS
p_errors_msvc_style(void)
#else
p_errors_msvc_style()
char *s;
char *t;
#endif
{                     
  printf_stderr_cfg(ERR_DIAG_FMT_MSVC, NULL, -1, NULL);
}

void 
#ifdef __USE_PROTOS
p_errors_mpw_style(void)
#else
p_errors_mpw_style()
char *s;
char *t;
#endif
{                     
  printf_stderr_cfg(ERR_DIAG_FMT_MPW, NULL, -1, NULL);
}





extern void fatal(char *message, int line_no);

void
#ifdef __USE_PROTOS
p_response_file(int *argc_ptr, char ***argv_ptr, char *s, char *t)
#else
p_response_file(argc_ptr, argv_ptr, s, t)
int *argc_ptr;
char ***argv_ptr;
char *s;
char *t;
#endif
{
  FILE *f;
  char *buf;
  long int len;
  char **newargv;
  int newargc;
  char *dst;
  char *src;
  int i;
  int j;

  if (!t)
  {
    fatal("-rsp requires a filename as argument...",0);
  }
  f = fopen(t, "r");
  if (!f)
  {
    fatal("Cannot open -rsp response file...",0);
  }
  fseek(f, 0, SEEK_END);
  len = ftell(f) + 2;
  fseek(f, 0, SEEK_SET);
  buf = (char *)malloc(len);
  if (!buf)
  {
    fatal("Cannot allocate response file processing buffer...",0);
  }
  len = fread(buf, 1, len, f);
  if (len < 0)
  {
    fatal("Cannot read response file...",0);
  }
  /* double sentinel! */
  buf[len++] = 0;
  buf[len++] = 0;

  /* decode buf[] into argv list... */
  for (newargc = 0, src = dst = buf; *src; )
  {
    switch (*src)
    {
    case '\"':
      /* boudble-quoted string applies only if double-quote found at start of argv element */
      if (src == buf || dst == buf || dst[-1] == 0)
      {
        /* quoted argument: skip/convert 'escaped' doublequotes, find next doublequote as terminator */
        for ( ; *src; )
        {
          switch (*src)
          {
          case '\\':
            if (src[1] == '\"')
            {
              *dst++ = '\"';
              src += 2;
              continue;
            }
            *dst++ = *src++;
            continue;

          case '\"':
            /* terminating quote */
            *dst++ = 0;
            newargc++;
            src++;
            break;

          /* accept \r and \n within string; you might consider this a bug though ;-) */
          default:
            *dst++ = *src++;
            continue;
          }
          break;
        }
        /* yes, "" is an _empty_ argument! it's allowed this way! */
        break;
      }
      /* fall through */

    case '\r':
    case '\n':
    case ' ':
    case '\t':
    default:
      if (isspace(*src))
      {
        if (dst > buf && dst[-1] != 0)
        {
          *dst++ = 0;
          newargc++;
        }
        src++;
        continue;
      }
      /* else: non-whitespace: part of an argv[] element! */
      *dst++ = *src++;
      continue;
    }
  }
  *dst++ = 0; /* write extra NUL sentinel at end of list */

  /* now merge new/old argv elems */
  newargv = (char **)malloc(sizeof(newargv[0]) * (newargc + argc_ptr[0] + 2));
  if (!newargv)
  {
    fatal("Cannot allocate response file processing buffer...",0);
  }

  /* merge response file argv[] elems at location of -rsp option: front of list! */
  newargv[0] = "###"; /* dummy entry */
  for(i = 1, src = buf; i < newargc+1; i++)
  {
    newargv[i] = src;
    src = strchr(src, 0);
    if (src == NULL)
    {
      fatal("assert: src!=NULL",0);
    }
    src++;
  }

  /* now add remaining argv[] elems: argv_ptr[0][2] and beyond! */
  for (j = 2; j < argc_ptr[0]; j++, i++)
  {
    newargv[i] = argv_ptr[0][j];
  }

  /* add terminator */
  newargv[i] = NULL;

  /* patch pointers! */
  argc_ptr[0] = i;
  argv_ptr[0] = newargv;

  return;
}


#ifdef __cplusplus
typedef void (*WildFunc)(...);
#else
typedef void (*WildFunc)();
#endif

typedef struct {
			char *option;
			int  arg;
			WildFunc process;
			char *descr;
		} Opt;

Opt options[] = {
	{ "-CC", 0, (WildFunc)p_cpp, "Generate C++ output" },
	{ "-C0", 0, (WildFunc)p_comp0, "No compression (default)" },
	{ "-C1", 0, (WildFunc)p_comp1, "Compression level 1" },
	{ "-C2", 0, (WildFunc)p_comp2, "Compression level 2" },
	{ "-ga", 0, (WildFunc)p_ansi, "Generate ansi C"},
	{ "-Wambiguity", 0, (WildFunc)p_warn_ambig, "Warn if expressions ambiguous"},
	{ "-m", 1, (WildFunc)p_mode_file, "Rename lexical mode output file"},
	{ "-i", 0, (WildFunc)p_interactive, "Build interactive scanner (not valid for C++ mode)"},
	{ "-ci", 0, (WildFunc)p_case_i, "Make lexical analyzer case insensitive"},
	{ "-cl", 1, (WildFunc)p_cl_name, "Rename lexer class (DLGLexer); only used for -CC"},
	{ "-cs", 0, (WildFunc)p_case_s, "Make lexical analyzer case sensitive (default)"},
	{ "-o",  1, (WildFunc)p_outdir, OutputDirectoryOption},
	{ "-rsp", 2, (WildFunc)p_response_file, "Specify 'response file' which contains additional commandline parameters"},
	{ "-ebcc", 0, (WildFunc)p_errors_borland_style, "Output errors in Borland C/C++ IDE compatible format to stdout"},
	{ "-emsvc", 0, (WildFunc)p_errors_msvc_style, "Output errors in Microsoft Visual C/C++ compatible format to stderr"},
	{ "-empw", 0, (WildFunc)p_errors_mpw_style, "Output errors in Macintosh Programmers Workshop compatible format to stderr"},
	{ "-", 0, (WildFunc)p_stdio, "Use standard i/o rather than file"},
	{ "*", 0, (WildFunc)p_file, ""}, /* anything else is a file */
	{ NULL, 0, NULL }	
 };

#ifdef __USE_PROTOS
void ProcessArgs(int argc, char **argv, Opt *options)
#else
void ProcessArgs(argc, argv, options)
int argc;
char **argv;
Opt *options;
#endif
{
	Opt *p;
	
	while ( argc-- > 0 )
	{
		p = options;
		while ( p->option != NULL )
		{
			if ( strcmp(p->option, "*") == 0 ||
				 ci_strequ(p->option,*argv) )
			{
				switch ( p->arg )
				{
				case 2:
          if (argc > 0)
          {
            (*p->process)(&argc, &argv, *argv, *(argv+1) );
            argc--;
          }
          else
          {
            printf_stderr_continued("error: required argument for option %s omitted\n",*argv);
            exit(PCCTS_EXIT_FAILURE);
          }
					break;

				case 1:
          if (argc-- > 0)
          {
  					(*p->process)( *argv, *(argv+1) );
					  argv++;
          }
          else
          {
            printf_stderr_continued("error: required argument for option %s omitted\n",*argv);
            exit(PCCTS_EXIT_FAILURE);
          }
					break;

				case 0:
					(*p->process)( *argv );
					break;
			  }
				break;
			}
			p++;
		}
		argv++;
	}
}

#ifdef __USE_PROTOS
int main(int argc, char *argv[])
#else
int main(argc, argv)
int argc;
char *argv[];
#endif
{
    Save_argc=argc;                                                  
    Save_argv=argv;                                                  

    init();
	printf_stderr_continued("%s  Version %s   1989-2001\n", &(program[0]),
		&(version[0]));
	if ( argc == 1 )
	{
		Opt *p = options;
		printf_stderr_continued("%s [options] f1 f2 ... fn\n",argv[0]);
		while ( *(p->option) != '*' )
		{
			printf_stderr_continued("\t%s %s\t%s\n",
							p->option,
							(p->arg)?"___":"   ",
							p->descr);
			p++;
		}
	}else{
		ProcessArgs(argc-1, &(argv[1]), options);
		if (interactive && gen_cpp) {
			printf_stderr_continued("\n");
/***  MR21a This statement is wrong ! ***/
#if 0
***			printf_stderr_continued("Interactive lexer option (\"-i\") has no effect when in C++ mode\n");
***			printf_stderr_continued("because of extra buffering provided by ANTLRTokenBuffer class.\n");
***			printf_stderr_continued("\n");
#endif
		}
		input_stream = read_stream(file_str[0]);
		if (input_stream) {
			/* don't overwrite unless input okay */
			if ( gen_cpp ) {
				output_stream = write_stream(ClassName(CPP_FILE_SUFFIX));
				if ( file_str[1]!=NULL ) {
					warning("output file implicit in C++ mode; ignored...",0);
				}
				class_stream = write_stream(ClassName(".h"));
				mode_stream = class_stream;
			}
			else {
				output_stream = write_stream(file_str[1]);
				mode_stream = write_stream(mode_file);
			}
		}
		/* make sure that error reporting routines in grammar
		   know what the file really is */
		/* make sure that reading and writing somewhere */
		if (input_stream && output_stream && mode_stream) {
            p_top_head(output_stream); /* [i_a] always write our copyright in top! */
            p_top_head(mode_stream);   /* + write it to mode_stream too! */
			ANTLR(grammar(), input_stream);
		}
		p_class_def2();			/* MR1 */
	}
	if ( output_stream!=NULL ) fclose(output_stream);
	if ( !gen_cpp && mode_stream!=NULL ) fclose(mode_stream);
	if ( class_stream!=NULL ) fclose(class_stream);
	exit(PCCTS_EXIT_SUCCESS);
	return 0;		/* get rid of warning message MR1 */
}

/* initialize all the variables */
void 
#ifdef __USE_PROTOS
init(void)
#else
init()
#endif
{
	register int i;

#ifdef SPECIAL_INITS
	special_inits();					/* MR1 */
#endif
	used_chars = empty;
	used_classes = empty;
	/* make the valid character set */
	normal_chars = empty;
	/* NOTE: MIN_CHAR is EOF */
	/* NOTE: EOF is not quite a valid char, it is special. Skip it*/
	for (i = 1; i<CHAR_RANGE; ++i){
		set_orel(i,&normal_chars);
	}
	make_nfa_model_node();
	clear_hash();
	/* NOTE: need to set this flag before the lexer starts getting */
	/* tokens */
   	func_action = FALSE;	
}

/* stuff that needs to be reset when a new automaton is being built */
void 
#ifdef __USE_PROTOS
new_automaton_mode(void)					/* MR1 */
#else
new_automaton_mode()					/* MR1 */
#endif
{
	set_free(used_chars);
	clear_hash();
}



/* [i_a] introduced generic routine from writing error diagnostics to console/IDE */
static struct
{
  printf_stderr_format_t fmt_type;
  char *srcfile_for_report;
  int srcline_for_report;
  FILE *output_file;
  char *msgbuf;
  int msgbufsize;
  int line_started;  /* !0 if header has been written */
  int is_initialized;
} printf_stderr_cfgdata =
{
  ERR_DIAG_FMT_UNKNOWN,
  NULL,
  0,
  NULL,
  NULL,
  0
};

void printf_stderr_cfg(printf_stderr_format_t type, const char *srcfile_for_report, int srcline_for_report, FILE *output)
{
  if (type != ERR_DIAG_FMT_UNCHANGED)
  {
    printf_stderr_cfgdata.fmt_type = type;
  }
  if (srcfile_for_report != NULL)
  {
    if (printf_stderr_cfgdata.srcfile_for_report != NULL)
    {                                           
      if (0 != strcmp(printf_stderr_cfgdata.srcfile_for_report, srcfile_for_report))
      {
        free(printf_stderr_cfgdata.srcfile_for_report);
      }
      printf_stderr_cfgdata.srcfile_for_report = STRDUP(srcfile_for_report);
    }
    else
    {
      printf_stderr_cfgdata.srcfile_for_report = STRDUP(srcfile_for_report);
    }
  }
  if (srcline_for_report >= 0)
  {
    printf_stderr_cfgdata.srcline_for_report = srcline_for_report;
  }
  if (output != NULL)
  {
    printf_stderr_cfgdata.output_file = output;
  }

  if (printf_stderr_cfgdata.msgbuf == NULL)
  {
    printf_stderr_cfgdata.msgbufsize = 4096; /* this'll be large enough for a single line... */
    printf_stderr_cfgdata.msgbuf = (char *)malloc(printf_stderr_cfgdata.msgbufsize);
    if (NULL == printf_stderr_cfgdata.msgbuf)
    {
      printf_stderr_continued( "Cannot allocate error diagnostic scratch buffer.\n");
      exit(EXIT_FAILURE);
    }
    printf_stderr_cfgdata.msgbuf[0] = 0;
  }
  printf_stderr_cfgdata.is_initialized = !0;
}

static void printf_stderr_header(void)
{
  FILE *out;
  const char *srcname;
  const char *srcfile;
  int srcline;

  out = printf_stderr_file();

  srcfile = printf_stderr_cfgdata.srcfile_for_report;
  if (srcfile == NULL)
  {
    /* don't print a header (yet) */
    printf_stderr_cfgdata.line_started = !0;
    return;
  }
  srcname = strrchr(srcfile, '/');
  if (!srcname) srcname = strrchr(srcfile, '\\');
  if (!srcname) srcname = strrchr(srcfile, ':');
  if (!srcname) srcname = strrchr(srcfile, ']');
  if (!srcname) srcname = srcfile-1;
  srcname++;

  srcline = printf_stderr_cfgdata.srcline_for_report;

  switch (printf_stderr_cfgdata.fmt_type)
  {
  default:
  case ERR_DIAG_FMT_UNKNOWN:
    /* default: "%s, line %d:" */
    fprintf(out, "%s, line %d:", srcfile, srcline);
    break;

  case ERR_DIAG_FMT_MPW:
    /* Macintosh Programmer's Workshop */
    fprintf(out, "File \"%s\"; Line %d #", srcfile, srcline);
    break;

  case ERR_DIAG_FMT_MSVC:
    /* Microsoft Visual C++ environment */
    fprintf(out, "%s(%d) :", srcfile, srcline);
    break;

  case ERR_DIAG_FMT_BCC:
    /* Borland C/C++ IDE */
    //
    // Handle messages of the form:
    //    Type Filename ####: MessageText
    // where:
    //    Type is one of: "Error", "Warning", "Fatal"
    //    Filename is the name of the source module
    //    #### is a number representing the line in the source module
    //
    // Messages with this format are generated by most Borland Tools
    //
    fprintf(out, "Warning %s %d: ", srcfile, srcline);
    break;
  }

  printf_stderr_cfgdata.line_started = !0;
}

#ifdef PCCTS_USE_STDARG
void printf_stderr(const char *srcfile, int srcline, const char *fmt, ...)
#else
void printf_stderr(va_alist)
va_dcl
#endif
{
  va_list args;
#ifndef PCCTS_USE_STDARG			/* MR20 */
	char *srcfile;
	int srcline;
	const char *fmt;
#endif
  FILE *out;
  char *p;
  char *str;

#ifdef PCCTS_USE_STDARG         /* MR20 */
	va_start(args, fmt);
#else
	va_start(ap);
	srcfile = va_arg(ap, char *);
	srcline = va_arg(ap, int);
	fmt = va_arg(ap, char *);
#endif

  if (!printf_stderr_cfgdata.is_initialized)
  {
    printf_stderr_cfg(ERR_DIAG_FMT_UNCHANGED, NULL, -1, NULL);
  }

  out = printf_stderr_file();

  /* copy old data out first! */
  str = printf_stderr_cfgdata.msgbuf;
  while (str[0] != 0)
  {                                 
    if (!printf_stderr_cfgdata.line_started)
    {
      printf_stderr_header();
    }
    p = strchr(str, '\n');
    if (!p)
    {
      p = str + strlen(str);
      p[1] = 0;
    }
    *p++ = 0;
    fputs(str, out);
    fputs("\n", out);
    printf_stderr_cfgdata.line_started = 0;
    str = p;
  }
  printf_stderr_cfgdata.msgbuf[0] = 0;
  
  /* keep 'defaults' up to date... */
  printf_stderr_cfg(ERR_DIAG_FMT_UNCHANGED, srcfile, srcline, NULL);

  vsprintf(printf_stderr_cfgdata.msgbuf, fmt, args);
  va_end(args);

  /* copy new data out now 'till first newline! */
  str = printf_stderr_cfgdata.msgbuf;
  for (;;)
  {                                 
    if (!printf_stderr_cfgdata.line_started)
    {
      printf_stderr_header();
    }
    p = strchr(str, '\n');
    if (!p)
    {
      /* move remaining data to front: */
      p = str;
      for (str = printf_stderr_cfgdata.msgbuf; *str++ = *p++; )
        ;
      *str = 0;
      break;
    }
    *p++ = 0;
    fputs(str, out);
    fputs("\n", out);
    printf_stderr_cfgdata.line_started = 0;
    str = p;
    if (str[0] == 0)
    {
      printf_stderr_cfgdata.msgbuf[0] = 0;
      break;
    }
  }
}

#ifdef PCCTS_USE_STDARG
int printf_stderr_continued(const char *fmt, ...)
#else
int printf_stderr_continued(va_alist)
va_dcl
#endif
{
  va_list args;
#ifndef PCCTS_USE_STDARG			/* MR20 */
	const char *fmt;
#endif
  FILE *out;
  char *str;
  char *p;

#ifdef PCCTS_USE_STDARG         /* MR20 */
	va_start(args, fmt);
#else
	va_start(ap);
	fmt = va_arg(ap, char *);
#endif

  if (!printf_stderr_cfgdata.is_initialized)
  {
    printf_stderr_cfg(ERR_DIAG_FMT_UNCHANGED, NULL, -1, NULL);
  }

  out = printf_stderr_file();

  str = printf_stderr_cfgdata.msgbuf;
  vsprintf(str += strlen(str), fmt, args);
  va_end(args);

  /* copy new data out now 'till first newline! */
  str = printf_stderr_cfgdata.msgbuf;
  for (;;)
  {
    if (!printf_stderr_cfgdata.line_started)
    {
      printf_stderr_header();
    }
    p = strchr(str, '\n');
    if (!p)
    {
      /* move remaining data to front: */
      if (str != printf_stderr_cfgdata.msgbuf)
      {
        p = str;
        for (str = printf_stderr_cfgdata.msgbuf; *str++ = *p++; )
          ;
        *str = 0;
      }
      else
      {
        str += strlen(str);
      }

      /* to prevent buffer overflow: copy line out anyway if fill > 2/3 */
      if (printf_stderr_cfgdata.msgbufsize * 2 < strlen(printf_stderr_cfgdata.msgbuf) * 3)
      {
        /* copy out anyway... */
        str[1] = 0;
        p = str;
        str = printf_stderr_cfgdata.msgbuf;
      }
      else
      {
        break;
      }
    }
    *p++ = 0;
    fputs(str, out);
    fputs("\n", out);
    printf_stderr_cfgdata.line_started = 0;
    str = p;
    if (str[0] == 0)
    {
      printf_stderr_cfgdata.msgbuf[0] = 0;
      break;
    }
  }
  return 0;
}


FILE *printf_stderr_file(void)
{
  if (printf_stderr_cfgdata.output_file != NULL)
  {
    return printf_stderr_cfgdata.output_file;
  }
  switch (printf_stderr_cfgdata.fmt_type)
  {                         
  case ERR_DIAG_FMT_UNKNOWN:
    /* default: "%s, line %d:" */
    return stderr;
    
  case ERR_DIAG_FMT_MPW:
    /* Macintosh Programmer's Workshop */
    return stderr;
    
  case ERR_DIAG_FMT_MSVC:
    /* Microsoft Visual C++ environment */
    return stderr;
    
  case ERR_DIAG_FMT_BCC:
    /* Borland C/C++ IDE */
    return stdout;
  }
  return stderr;
}

