/*
 * dumpnode.c 
 *
 * SOFTWARE RIGHTS
 *
 * We reserve no LEGAL rights to the Purdue Compiler Construction Tool
 * Set (PCCTS) -- PCCTS is in the public domain.  An individual or
 * company may do whatever they wish with source code distributed with
 * PCCTS or the code generated by PCCTS, including the incorporation of
 * PCCTS, or its output, into commerical software.
 *
 * We encourage users to develop software with PCCTS.  However, we do ask
 * that credit is given to us for developing PCCTS.  By "credit",
 * we mean that if you incorporate our source code into one of your
 * programs (commercial product, research project, or otherwise) that you
 * acknowledge this fact somewhere in the documentation, research report,
 * etc...  If you like PCCTS and have developed a nice tool with the
 * output, please mention that you developed it using PCCTS.  In
 * addition, we ask that this header remain intact in our source code.
 * As long as these guidelines are kept, we expect to continue enhancing
 * this system and expect to make other tools available as they are
 * completed.
 *
 * ANTLR 1.33
 * Terence Parr
 * Parr Research Corporation
 * with Purdue University and AHPCRC, University of Minnesota
 * 1989-2001
 */

#include <stdio.h>
#include <ctype.h>

#include "set.h"
#include "syn.h"
#include "hash.h"
#include "generic.h"

#ifdef __USE_PROTOS
void dumpset1(set s)
#else
void dumpset1(s)
  set   s;
#endif
{
  if (set_nil(s)) {
    printf_stderr_continued("{}");
  } else {
    s_fprT(stderr,s);
  }
}

#ifdef __USE_PROTOS
void dumpset(set s)
#else
void dumpset(s)
  set   s;
#endif
{
  dumpset1(s);
  printf_stderr_continued("\n");
}

#ifdef __USE_PROTOS
int isEndRule(Node * p)
#else
int isEndRule(p)
  Node *    p;
#endif
{
  int       result=0;
  if ( p->ntype == nJunction &&
       ( (Junction *) p)->jtype == EndRule) {
    result=1;
  }
  return result;
}

#ifdef __USE_PROTOS
void dumppred1(int depth,Predicate *p)
#else
void dumppred1(depth,p)
  int           depth;
  Predicate     *p;
#endif
{
  int       i;
  int       k;

  for (i=0; i<depth ; i++) {
    printf_stderr_continued("  ");
  }
  if (p->expr == PRED_AND_LIST ||
      p->expr == PRED_OR_LIST) {
    printf_stderr_continued(" %s", (p->expr == NULL ? "null expr" : p->expr));
    if (p->inverted) printf_stderr_continued(" predicate inverted !");
    if (p->redundant) {
      printf_stderr_continued(" Redundant!");
    }
    if (p->isConst) printf_stderr_continued(" const %d !",p->constValue);
    printf_stderr_continued("\n");
  } else {
    printf_stderr_continued("predicate k=%d",p->k);
    k=set_int(p->completionSet);
    if (k >= 0) {
      printf_stderr_continued(" Incomplete Set=%d !",k);
    }
    k=set_int(p->completionTree);
    if (k >= 0) {
      printf_stderr_continued(" Incomplete Tree=%d !",k);
    }
    if (p->redundant) {
      printf_stderr_continued(" Redundant!");
    }
    printf_stderr_continued(" \"%s\" (%x)", (p->expr == NULL ? "null expr" : p->expr) ,p);
    if (p->source != NULL) {
       printf_stderr_continued("line %d",p->source->line);
    }
    if (p->inverted) printf_stderr_continued(" predicate inverted !");
    printf_stderr_continued("\n");
    for (i=0; i<depth ; i++) {
      printf_stderr_continued("  ");
    }
    printf_stderr_continued("scontext: ");
    dumpset(p->scontext[1]);
    for (i=0; i<depth ; i++) {
      printf_stderr_continued("  ");
    }
    printf_stderr_continued("tcontext: ");
    preorder(p->tcontext);
    printf_stderr_continued("\n");
  }
  printf_stderr_continued("\n");
  if (p->down != NULL) {
    dumppred1(depth+1,p->down);
  }
  if (p->right != NULL) {
    dumppred1(depth,p->right);
  }
}

#ifdef __USE_PROTOS
void dumppred(Predicate *p)
#else
void dumppred(p)
  Predicate     *p;
#endif
{
  printf_stderr_continued("---------------------------------\n");
  dumppred1(0,p);
  printf_stderr_continued("\n");
}

#ifdef __USE_PROTOS
void dumppredtree(Predicate *p)
#else
void dumppredtree(p)
  Predicate     *p;
#endif
{
  printf_stderr_continued("predicate k=%d \"%s\" line %d\n",p->k,p->expr,p->source->line);
  dumpset(p->scontext[1]);
}

#ifdef __USE_PROTOS
void dumppredexpr(Predicate *p)
#else
void dumppredexpr(p)
  Predicate     *p;
#endif
{
  printf_stderr_continued("    pred expr \"%s\"\n",p->expr);
}

#ifdef __USE_PROTOS
void dt(Tree *t)
#else
void dt(t)
  Tree  *t;
#endif
{
  MR_dumpTreeF(stderr,0,t,5);
}

#ifdef __USE_PROTOS
void d(Node * p)
#else
void d(p)
  Node *    p;
#endif
{

  Junction      *j;
  RuleRefNode   *r;
  TokNode       *t;
  ActionNode    *a;

  if (p==NULL) {
    printf_stderr_continued("dumpNode: Node is NULL");
    return;
  }

  switch (p->ntype) {
    case nJunction :
      j = (Junction *) p;
      printf_stderr_continued( "Junction (#%d in rule %s line %d) ",j->seq,j->rname,j->line);
      if (j->guess) printf_stderr_continued("guess block ");
      switch (j->jtype ) {
        case aSubBlk :
          printf_stderr_continued("aSubBlk");
          break;
        case aOptBlk :
          printf_stderr_continued("aOptBlk");
          break;
        case aLoopBegin :
          printf_stderr_continued("aLoopBeginBlk");
          break;
        case aLoopBlk :
          printf_stderr_continued("aLoopBlk");
          break;
        case aPlusBlk :
          printf_stderr_continued("aPlusBlk");
          break;
        case EndBlk :
          printf_stderr_continued("EndBlk");
          break;
        case RuleBlk :
          printf_stderr_continued("RuleBlk");
          break;
        case Generic :
          printf_stderr_continued("Generic");
          break;
        case EndRule :
          printf_stderr_continued("EndRule");
          break;
      }
      if (j->halt) printf_stderr_continued("  halt!");
      if (j->p1) printf_stderr_continued(" p1 valid");
      if (j->p2) {
        if (j->p2->ntype == nJunction) {
           printf_stderr_continued(" (p2=#%d)",( (Junction *) j->p2)->seq);
        } else {
           printf_stderr_continued(" (p2 valid)");
        }
      }
	  if (j->ignore) printf_stderr_continued(" ignore/plus-block-bypass");
      if (j->fset != NULL && set_deg(*j->fset) != 0) {
         printf_stderr_continued("\nfset:\n");
         dumpset(*j->fset);
      }
      if (j->ftree != NULL) {
         printf_stderr_continued("\nftree:\n");
         preorder(j->ftree);
      }
      printf_stderr_continued("\n");
      break;
    case nRuleRef :
       r = (RuleRefNode *) p;
       printf_stderr_continued( "RuleRefNode (in rule %s line %d) to rule %s\n", r->rname,r->line,r->text);
       break;
    case nToken :
       t = (TokNode *) p;
       printf_stderr_continued( "TokNode (in rule %s line %d) token %s\n",t->rname,t->line,TerminalString(t->token));
       break;
    case nAction :
       a =(ActionNode *) p;
       if (a->is_predicate) {
         printf_stderr_continued( "Predicate (in rule %s line %d) %s",a->rname,a->line,a->action);
         if (a->inverted) printf_stderr_continued(" action inverted !");
         if (a->guardpred != NULL) {
           printf_stderr_continued(" guarded");
           dumppredexpr(a->guardpred);
           if (a->ampersandPred) {
             printf_stderr_continued(" \"&&\" style");
           } else {
             printf_stderr_continued(" \"=>\" style");
           }
         }
         if (a->predEntry != NULL) printf_stderr_continued(" predEntry \"%s\" ",a->predEntry->str);
         printf_stderr_continued("\n");
       } else if (a->init_action) {
         printf_stderr_continued( "Init-Action (in rule %s line %d) %s\n",a->rname,a->line,a->action);
       } else {
         printf_stderr_continued( "Action (in rule %s line %d) %s\n",a->rname,a->line,a->action);
       }
       break;
   }
}

#ifdef __USE_PROTOS
Node * dp1(Node * p)
#else
Node * dp1(p)
  Node *    p;
#endif
{
  Node  *result=NULL;

  if (p->ntype == nJunction) {
    result=( (Junction *) p )->p1;
    d(result);
  } else {
    printf_stderr_continued("dp1: Not a Junction node");
  }
  return result;
}

#ifdef __USE_PROTOS
Node * dp2(Node * p)
#else
Node * dp2(p)
  Node *    p;
#endif
{
  Node  *result=NULL;

  if (p->ntype == nJunction) {
    result=( (Junction *) p )->p2;
    d(result);
  } else {
    printf_stderr_continued("dp2: Not a Junction node");
  }
  return result;
}

#ifdef __USE_PROTOS
Node * dn(Node * p)
#else
Node * dn(p)
  Node *    p;
#endif

{
  Node  *result=NULL;

  if (p->ntype == nRuleRef) {
    result=( (RuleRefNode *)p )->next;
  } else if (p->ntype == nAction) {
    result=( (ActionNode *)p )->next;
  } else if (p->ntype == nToken) {
    result=( (TokNode *)p )->next;
  } else {
    printf_stderr_continued("No next field: Neither a RuleRefNode, ActionNode, nor TokNode");
  }
  if (result != NULL) d(result);
  return result;
}

#ifdef __USE_PROTOS
void df(Node * p)
#else
void df(p)
  Node *    p;
#endif
{
  int       count=0;
  Node      *next;

  printf_stderr_continued("\n#%d ",++count);
  d(p);

  for (next=p; next != NULL && !isEndRule(next) ; ) {
    printf_stderr_continued("#%d ",++count);
    if (next->ntype == nJunction) {
      next=dp1(next);
    } else {
      next=dn(next);
    }
  }
}

#ifdef __USE_PROTOS
Node * dfn(Node * p,int target)
#else
Node * dfn(p,target)
  Node *    p;
  int       target;
#endif
{
  Node      *result=NULL;
  int       count=0;
  Node      *next;

  printf_stderr_continued("#%d ",++count);
  d(p);

  for (next=p; next != NULL && !isEndRule(next) ; ) {
    printf_stderr_continued("#%d ",++count);
    if (next->ntype == nJunction) {
      next=dp1(next);
    } else {
      next=dn(next);
    }
    if (count == target) {
      result=next;
      break;
    }
  }
  return result;
}


static int findnodeMatch;

#ifdef __USE_PROTOS
Junction *findnode1(Node *n)
#else
Junction *findnode1(n)
  Node  *n;
#endif
{
   Node         *next;
   Junction     *j;
   Junction     *match;

   if (n == NULL) return NULL;
   if (n->ntype == nJunction) {
     j=(Junction *) n;
     if (j->seq == findnodeMatch) return j;
     if (j->jtype == EndRule) return NULL;
     if (j->jtype != RuleBlk && j->jtype != EndBlk) {
       if (j->p2 != NULL && !j->ignore) {
          match=findnode1(j->p2);
          if (match != NULL) return match;
       }
     }
   }
   next=MR_advance(n);
   return findnode1(next);
}

#ifdef __USE_PROTOS
Junction *findnode(int match)
#else
Junction *findnode(match)
  int   match;
#endif
{
  Junction  *j;
  Junction  *result=NULL;

  findnodeMatch=match;

  for (j=SynDiag; j != NULL; j=(Junction *)j->p2) {
    require (j->ntype == nJunction && j->jtype == RuleBlk,"Not a rule block");
    result=findnode1( (Node *) j);
    if (result != NULL) break;
  }
  if (result != NULL) {
    d( (Node *) result);
  }
  return result;
}
