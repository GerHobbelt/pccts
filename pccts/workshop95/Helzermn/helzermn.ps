%!PS-Adobe-3.0
%%BoundingBox: (atend)
%%Pages: (atend)
%%PageOrder: (atend)
%%DocumentFonts: (atend)
%%Creator: Frame 4.0
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
%
% Frame ps_prolog 4.0, for use with Frame 4.0 products
% This ps_prolog file is Copyright (c) 1986-1993 Frame Technology
% Corporation.  All rights reserved.  This ps_prolog file may be
% freely copied and distributed in conjunction with documents created
% using FrameMaker, FrameBuilder and FrameViewer as long as this 
% copyright notice is preserved.
%
% Frame products normally print colors as their true color on a color printer
% or as shades of gray, based on luminance, on a black-and white printer. The
% following flag, if set to True, forces all non-white colors to print as pure
% black. This has no effect on bitmap images.
/FMPrintAllColorsAsBlack             false def
%
% Frame products can either set their own line screens or use a printer's 
% default settings. Three flags below control this separately for no 
% separations, spot separations and process separations. If a flag
% is true, then the default printer settings will not be changed. If it is
% false, Frame products will use their own settings from a table based on
% the printer's resolution.
/FMUseDefaultNoSeparationScreen      true  def
/FMUseDefaultSpotSeparationScreen    true  def
/FMUseDefaultProcessSeparationScreen false def
%
% For any given PostScript printer resolution, Frame products have two sets of 
% screen angles and frequencies for printing process separations, which are 
% recomended by Adobe. The following variable chooses the higher frequencies
% when set to true or the lower frequencies when set to false. This is only
% effective if the appropriate FMUseDefault...SeparationScreen flag is false.
/FMUseHighFrequencyScreens true def
%
% PostScript Level 2 printers contain an "Accurate Screens" feature which can
% improve process separation rendering at the expense of compute time. This 
% flag is ignored by PostScript Level 1 printers.
/FMUseAcccurateScreens true def
%
% The following PostScript procedure defines the spot function that Frame
% products will use for process separations. You may un-comment-out one of
% the alternative functions below, or use your own.
%
% Dot function
/FMSpotFunction {abs exch abs 2 copy add 1 gt 
                {1 sub dup mul exch 1 sub dup mul add 1 sub }
                {dup mul exch dup mul add 1 exch sub }ifelse } def
%
% Line function
% /FMSpotFunction { pop } def
%
% Elipse function
% /FMSpotFunction { dup 5 mul 8 div mul exch dup mul exch add 
%               sqrt 1 exch sub } def
%
%
/FMversion (4.0) def 
/FMLevel1 /languagelevel where {pop languagelevel} {1} ifelse 2 lt def
/FMPColor
        FMLevel1 {
                false
                /colorimage where {pop pop true} if
        } {
                true
        } ifelse
def
/FrameDict 400 dict def 
systemdict /errordict known not {/errordict 10 dict def
                errordict /rangecheck {stop} put} if
% The readline in PS 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
        /readline {
                /gstring exch def
                /gfile exch def
                /gindex 0 def
                {
                        gfile read pop 
                        dup 10 eq {exit} if 
                        dup 13 eq {exit} if 
                        gstring exch gindex exch put 
                        /gindex gindex 1 add def 
                } loop
                pop 
                gstring 0 gindex getinterval true 
                } bind def
        } if
/FMshowpage /showpage load def
/FMquit /quit load def
/FMFAILURE { 
        dup = flush 
        FMshowpage 
        /Helvetica findfont 12 scalefont setfont
        72 200 moveto
        show FMshowpage 
        FMquit 
        } def 
/FMVERSION {
        FMversion ne {
                (Frame product version does not match ps_prolog!) FMFAILURE
                } if
        } def 
/FMBADEPSF { 
        (PostScript Lang. Ref. Man., 2nd Ed., H.2.4 says EPS must not call X              )
        dup dup (X) search pop exch pop exch pop length 
        4 -1 roll 
        putinterval 
        FMFAILURE
        } def
/FMLOCAL {
        FrameDict begin
        0 def 
        end 
        } def 
/concatprocs
        {
        /proc2 exch cvlit def/proc1 exch cvlit def/newproc proc1 length proc2 length add array def
        newproc 0 proc1 putinterval newproc proc1 length proc2 putinterval newproc cvx
}def
FrameDict begin 
/FMnone 0 def
/FMcyan 1 def
/FMmagenta 2 def
/FMyellow 3 def
/FMblack 4 def
/FMcustom 5 def
/FrameNegative false def 
/FrameSepIs FMnone def 
/FrameSepBlack 0 def
/FrameSepYellow 0 def
/FrameSepMagenta 0 def
/FrameSepCyan 0 def
/FrameSepRed 1 def
/FrameSepGreen 1 def
/FrameSepBlue 1 def
/FrameCurGray 1 def
/FrameCurPat null def
/FrameCurColors [ 0 0 0 1 0 0 0 ] def 
/FrameColorEpsilon .001 def     
/eqepsilon {            
        sub dup 0 lt {neg} if
        FrameColorEpsilon le
} bind def
/FrameCmpColorsCMYK { 
        2 copy 0 get exch 0 get eqepsilon {
                2 copy 1 get exch 1 get eqepsilon {
                        2 copy 2 get exch 2 get eqepsilon {
                                3 get exch 3 get eqepsilon
                        } {pop pop false} ifelse
                }{pop pop false} ifelse
        } {pop pop false} ifelse
} bind def
/FrameCmpColorsRGB { 
        2 copy 4 get exch 0 get eqepsilon {
                2 copy 5 get exch 1 get eqepsilon {
                        6 get exch 2 get eqepsilon
                }{pop pop false} ifelse
        } {pop pop false} ifelse
} bind def
/RGBtoCMYK { 
        1 exch sub 
        3 1 roll 
        1 exch sub 
        3 1 roll 
        1 exch sub 
        3 1 roll 
        3 copy 
        2 copy 
        le { pop } { exch pop } ifelse 
        2 copy 
        le { pop } { exch pop } ifelse 
        dup dup dup 
        6 1 roll 
        4 1 roll 
        7 1 roll 
        sub 
        6 1 roll 
        sub 
        5 1 roll 
        sub 
        4 1 roll 
} bind def
/CMYKtoRGB { 
        dup dup 4 -1 roll add                                             
        5 1 roll 3 -1 roll add                                            
        4 1 roll add                                                              
        1 exch sub dup 0 lt {pop 0} if 3 1 roll           
        1 exch sub dup 0 lt {pop 0} if exch           
        1 exch sub dup 0 lt {pop 0} if exch                       
} bind def
/FrameSepInit {
        1.0 RealSetgray
} bind def
/FrameSetSepColor { 
        /FrameSepBlue exch def
        /FrameSepGreen exch def
        /FrameSepRed exch def
        /FrameSepBlack exch def
        /FrameSepYellow exch def
        /FrameSepMagenta exch def
        /FrameSepCyan exch def
        /FrameSepIs FMcustom def
        setCurrentScreen        
} bind def
/FrameSetCyan {
        /FrameSepBlue 1.0 def
        /FrameSepGreen 1.0 def
        /FrameSepRed 0.0 def
        /FrameSepBlack 0.0 def
        /FrameSepYellow 0.0 def
        /FrameSepMagenta 0.0 def
        /FrameSepCyan 1.0 def
        /FrameSepIs FMcyan def
        setCurrentScreen        
} bind def
 
/FrameSetMagenta {
        /FrameSepBlue 1.0 def
        /FrameSepGreen 0.0 def
        /FrameSepRed 1.0 def
        /FrameSepBlack 0.0 def
        /FrameSepYellow 0.0 def
        /FrameSepMagenta 1.0 def
        /FrameSepCyan 0.0 def
        /FrameSepIs FMmagenta def
        setCurrentScreen
} bind def
 
/FrameSetYellow {
        /FrameSepBlue 0.0 def
        /FrameSepGreen 1.0 def
        /FrameSepRed 1.0 def
        /FrameSepBlack 0.0 def
        /FrameSepYellow 1.0 def
        /FrameSepMagenta 0.0 def
        /FrameSepCyan 0.0 def
        /FrameSepIs FMyellow def
        setCurrentScreen
} bind def
 
/FrameSetBlack {
        /FrameSepBlue 0.0 def
        /FrameSepGreen 0.0 def
        /FrameSepRed 0.0 def
        /FrameSepBlack 1.0 def
        /FrameSepYellow 0.0 def
        /FrameSepMagenta 0.0 def
        /FrameSepCyan 0.0 def
        /FrameSepIs FMblack def
        setCurrentScreen
} bind def
 
/FrameNoSep { 
        /FrameSepIs FMnone def
        setCurrentScreen
} bind def
/FrameSetSepColors { 
        FrameDict begin
        [ exch 1 add 1 roll ]
        /FrameSepColors  
        exch def end
        } bind def
/FrameColorInSepListCMYK { 
        FrameSepColors {  
                exch dup 3 -1 roll 
                FrameCmpColorsCMYK 
                { pop true exit } if
        } forall 
        dup true ne {pop false} if
        } bind def
/FrameColorInSepListRGB { 
        FrameSepColors {  
                exch dup 3 -1 roll 
                FrameCmpColorsRGB 
                { pop true exit } if
        } forall 
        dup true ne {pop false} if
        } bind def
/RealSetgray /setgray load def
/RealSetrgbcolor /setrgbcolor load def
/RealSethsbcolor /sethsbcolor load def
end 
/setgray { 
        FrameDict begin
        FrameSepIs FMnone eq
                { RealSetgray } 
                { 
                FrameSepIs FMblack eq 
                        { RealSetgray } 
                        { FrameSepIs FMcustom eq 
                          FrameSepRed 0 eq and
                          FrameSepGreen 0 eq and
                          FrameSepBlue 0 eq and {
                                RealSetgray
                          } {
                                1 RealSetgray pop 
                          } ifelse
                        } ifelse
                } ifelse
        end
} bind def
/setrgbcolor { 
        FrameDict begin
        FrameSepIs FMnone eq
        {  RealSetrgbcolor }
        {
                3 copy [ 4 1 roll ] 
                FrameColorInSepListRGB
                {
                                FrameSepBlue eq exch 
                                FrameSepGreen eq and exch 
                                FrameSepRed eq and
                                { 0 } { 1 } ifelse
                }
                {
                        FMPColor {
                                RealSetrgbcolor
                                currentcmykcolor
                        } {
                                RGBtoCMYK
                        } ifelse
                        FrameSepIs FMblack eq
                        {1.0 exch sub 4 1 roll pop pop pop} {
                        FrameSepIs FMyellow eq
                        {pop 1.0 exch sub 3 1 roll pop pop} {
                        FrameSepIs FMmagenta eq
                        {pop pop 1.0 exch sub exch pop } {
                        FrameSepIs FMcyan eq
                        {pop pop pop 1.0 exch sub } 
                        {pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
                } ifelse
                RealSetgray
        } 
        ifelse
        end
} bind def
/sethsbcolor {
        FrameDict begin
        FrameSepIs FMnone eq 
        { RealSethsbcolor } 
        {
                RealSethsbcolor 
                currentrgbcolor  
                setrgbcolor 
        } 
        ifelse
        end
} bind def
FrameDict begin
/setcmykcolor where {
        pop /RealSetcmykcolor /setcmykcolor load def
} {
        /RealSetcmykcolor {
                4 1 roll
                3 { 3 index add 0 max 1 min 1 exch sub 3 1 roll} repeat 
                setrgbcolor pop
        } bind def
} ifelse
userdict /setcmykcolor { 
                FrameDict begin
                FrameSepIs FMnone eq
                { RealSetcmykcolor } 
                {
                        4 copy [ 5 1 roll ]
                        FrameColorInSepListCMYK
                        {
                                FrameSepBlack eq exch 
                                FrameSepYellow eq and exch 
                                FrameSepMagenta eq and exch 
                                FrameSepCyan eq and 
                                { 0 } { 1 } ifelse
                        }
                        {
                                FrameSepIs FMblack eq
                                {1.0 exch sub 4 1 roll pop pop pop} {
                                FrameSepIs FMyellow eq
                                {pop 1.0 exch sub 3 1 roll pop pop} {
                                FrameSepIs FMmagenta eq
                                {pop pop 1.0 exch sub exch pop } {
                                FrameSepIs FMcyan eq
                                {pop pop pop 1.0 exch sub } 
                                {pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
                        } ifelse
                        RealSetgray
                }
                ifelse
                end
        } bind put
FMLevel1 not { 
        
        /patProcDict 5 dict dup begin
                <0f1e3c78f0e1c387> { 3 setlinewidth -1 -1 moveto 9 9 lineto stroke 
                                                                                        4 -4 moveto 12 4 lineto stroke
                                                                                        -4 4 moveto 4 12 lineto stroke} bind def
                <0f87c3e1f0783c1e> { 3 setlinewidth -1 9 moveto 9 -1 lineto stroke 
                                                                                        -4 4 moveto 4 -4 lineto stroke
                                                                                        4 12 moveto 12 4 lineto stroke} bind def
                <8142241818244281> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke
                                                                                        -1 -1 moveto 9 9 lineto stroke } bind def
                <03060c183060c081> { 1 setlinewidth -1 -1 moveto 9 9 lineto stroke 
                                                                                        4 -4 moveto 12 4 lineto stroke
                                                                                        -4 4 moveto 4 12 lineto stroke} bind def
                <8040201008040201> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke 
                                                                                        -4 4 moveto 4 -4 lineto stroke
                                                                                        4 12 moveto 12 4 lineto stroke} bind def
        end def
        /patDict 15 dict dup begin
                /PatternType 1 def              
                /PaintType 2 def                
                /TilingType 3 def               
                /BBox [ 0 0 8 8 ] def   
                /XStep 8 def                    
                /YStep 8 def                    
                /PaintProc {
                        begin
                        patProcDict bstring known {
                                patProcDict bstring get exec
                        } {
                                8 8 true [1 0 0 -1 0 8] bstring imagemask
                        } ifelse
                        end
                } bind def
        end def
} if
/combineColor {
    FrameSepIs FMnone eq
        {
                graymode FMLevel1 or not {
                        
                        [/Pattern [/DeviceCMYK]] setcolorspace
                        FrameCurColors 0 4 getinterval aload pop FrameCurPat setcolor
                } {
                        FrameCurColors 3 get 1.0 ge {
                                FrameCurGray RealSetgray
                        } {
                                FMPColor graymode and {
                                        0 1 3 { 
                                                FrameCurColors exch get
                                                1 FrameCurGray sub mul
                                        } for
                                        RealSetcmykcolor
                                } {
                                        4 1 6 {
                                                FrameCurColors exch get
                                                graymode {
                                                        1 exch sub 1 FrameCurGray sub mul 1 exch sub
                                                } {
                                                        1.0 lt {FrameCurGray} {1} ifelse
                                                } ifelse
                                        } for
                                        RealSetrgbcolor
                                } ifelse
                        } ifelse
                } ifelse
        } { 
                FrameCurColors 0 4 getinterval aload
                FrameColorInSepListCMYK {
                        FrameSepBlack eq exch 
                        FrameSepYellow eq and exch 
                        FrameSepMagenta eq and exch 
                        FrameSepCyan eq and
                        FrameSepIs FMcustom eq and
                        { FrameCurGray } { 1 } ifelse
                } {
                        FrameSepIs FMblack eq
                        {FrameCurGray 1.0 exch sub mul 1.0 exch sub 4 1 roll pop pop pop} {
                        FrameSepIs FMyellow eq
                        {pop FrameCurGray 1.0 exch sub mul 1.0 exch sub 3 1 roll pop pop} {
                        FrameSepIs FMmagenta eq
                        {pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub exch pop } {
                        FrameSepIs FMcyan eq
                        {pop pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub } 
                        {pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
                } ifelse
                graymode FMLevel1 or not {
                        
                        [/Pattern [/DeviceGray]] setcolorspace
                        FrameCurPat setcolor
                } { 
                        graymode not FMLevel1 and {
                                
                                dup 1 lt {pop FrameCurGray} if
                        } if
                        RealSetgray
                } ifelse
        } ifelse
} bind def
/savematrix {
        orgmatrix currentmatrix pop
        } bind def
/restorematrix {
        orgmatrix setmatrix
        } bind def
/dmatrix matrix def
/dpi    72 0 dmatrix defaultmatrix dtransform
    dup mul exch   dup mul add   sqrt def
        
/freq dpi dup 72 div round dup 0 eq {pop 1} if 8 mul div def
/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
/dpiranges   [  2540    2400    1693     1270    1200     635      600      0      ] def
/CMLowFreqs  [ 100.402  94.8683 89.2289 100.402  94.8683  66.9349  63.2456 47.4342 ] def
/YLowFreqs   [  95.25   90.0    84.65    95.25   90.0     70.5556  66.6667 50.0    ] def
/KLowFreqs   [  89.8026 84.8528 79.8088  89.8026 84.8528  74.8355  70.7107 53.033  ] def
/CLowAngles  [  71.5651 71.5651 71.5651 71.5651  71.5651  71.5651  71.5651 71.5651 ] def
/MLowAngles  [  18.4349 18.4349 18.4349 18.4349  18.4349  18.4349  18.4349 18.4349 ] def
/YLowTDot    [  true    true    false    true    true     false    false   false   ] def
/CMHighFreqs [ 133.87  126.491 133.843  108.503 102.523  100.402   94.8683 63.2456 ] def
/YHighFreqs  [ 127.0   120.0   126.975  115.455 109.091   95.25    90.0    60.0    ] def
/KHighFreqs  [ 119.737 113.137 119.713  128.289 121.218   89.8026  84.8528 63.6395 ] def
/CHighAngles [  71.5651 71.5651 71.5651  70.0169 70.0169  71.5651  71.5651 71.5651 ] def
/MHighAngles [  18.4349 18.4349 18.4349  19.9831 19.9831  18.4349  18.4349 18.4349 ] def
/YHighTDot   [  false   false   true     false   false    true     true    false   ] def
/PatFreq     [  10.5833 10.0     9.4055  10.5833 10.0     10.5833  10.0    9.375   ] def
/screenIndex {
        0 1 dpiranges length 1 sub { dup dpiranges exch get 1 sub dpi le {exit} {pop} ifelse } for
} bind def
/getCyanScreen {
        FMUseHighFrequencyScreens { CHighAngles CMHighFreqs} {CLowAngles CMLowFreqs} ifelse
                screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getMagentaScreen {
        FMUseHighFrequencyScreens { MHighAngles CMHighFreqs } {MLowAngles CMLowFreqs} ifelse
                screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getYellowScreen {
        FMUseHighFrequencyScreens { YHighTDot YHighFreqs} { YLowTDot YLowFreqs } ifelse
                screenIndex dup 3 1 roll get 3 1 roll get { 3 div
                        {2 { 1 add 2 div 3 mul dup floor sub 2 mul 1 sub exch} repeat
                        FMSpotFunction } } {/FMSpotFunction load } ifelse
                        0.0 exch
} bind def
/getBlackScreen  {
        FMUseHighFrequencyScreens { KHighFreqs } { KLowFreqs } ifelse
                screenIndex get 45.0 /FMSpotFunction load 
} bind def
/getSpotScreen {
        getBlackScreen
} bind def
/getCompositeScreen {
        getBlackScreen
} bind def
/FMSetScreen 
        FMLevel1 { /setscreen load 
        }{ {
                8 dict begin
                /HalftoneType 1 def
                /SpotFunction exch def
                /Angle exch def
                /Frequency exch def
                /AccurateScreens FMUseAcccurateScreens def
                currentdict end sethalftone
        } bind } ifelse
def
/setDefaultScreen {
        FMPColor {
                orgrxfer cvx orggxfer cvx orgbxfer cvx orgxfer cvx setcolortransfer
        }
        {
                orgxfer cvx settransfer
        } ifelse
        orgfreq organgle orgproc cvx setscreen
} bind def
/setCurrentScreen {
        FrameSepIs FMnone eq {
                FMUseDefaultNoSeparationScreen {
                        setDefaultScreen
                } {
                        getCompositeScreen FMSetScreen
                } ifelse
        } {
                FrameSepIs FMcustom eq {
                        FMUseDefaultSpotSeparationScreen {
                                setDefaultScreen
                        } {
                                getSpotScreen FMSetScreen
                        } ifelse
                } {
                        FMUseDefaultProcessSeparationScreen {
                                setDefaultScreen
                        } {
                                FrameSepIs FMcyan eq {
                                        getCyanScreen FMSetScreen
                                } {
                                        FrameSepIs FMmagenta eq {
                                                getMagentaScreen FMSetScreen
                                        } {
                                                FrameSepIs FMyellow eq {
                                                        getYellowScreen FMSetScreen
                                                } {
                                                        getBlackScreen FMSetScreen
                                                } ifelse
                                        } ifelse
                                } ifelse
                        } ifelse
                } ifelse
        } ifelse 
} bind def
end
        /gstring FMLOCAL
        /gfile FMLOCAL
        /gindex FMLOCAL
        /orgrxfer FMLOCAL
        /orggxfer FMLOCAL
        /orgbxfer FMLOCAL
        /orgxfer FMLOCAL
        /orgproc FMLOCAL
        /orgrproc FMLOCAL
        /orggproc FMLOCAL
        /orgbproc FMLOCAL
        /organgle FMLOCAL
        /orgrangle FMLOCAL
        /orggangle FMLOCAL
        /orgbangle FMLOCAL
        /orgfreq FMLOCAL
        /orgrfreq FMLOCAL
        /orggfreq FMLOCAL
        /orgbfreq FMLOCAL
        /yscale FMLOCAL
        /xscale FMLOCAL
        /edown FMLOCAL
        /manualfeed FMLOCAL
        /paperheight FMLOCAL
        /paperwidth FMLOCAL
/FMDOCUMENT { 
        array /FMfonts exch def 
        /#copies exch def
        FrameDict begin
        0 ne /manualfeed exch def
        /paperheight exch def
        /paperwidth exch def
        0 ne /FrameNegative exch def 
        0 ne /edown exch def 
        /yscale exch def
        /xscale exch def
        FMLevel1 {
                manualfeed {setmanualfeed} if
                /FMdicttop countdictstack 1 add def 
                /FMoptop count def 
                setpapername 
                manualfeed {true} {papersize} ifelse 
                {manualpapersize} {false} ifelse 
                {desperatepapersize} {false} ifelse 
                { (Can't select requested paper size for Frame print job!) FMFAILURE } if
                count -1 FMoptop {pop pop} for
                countdictstack -1 FMdicttop {pop end} for 
                }
                {{1 dict dup /PageSize [paperwidth paperheight]put setpagedevice}stopped
                { (Can't select requested paper size for Frame print job!) FMFAILURE } if
                 {1 dict dup /ManualFeed manualfeed put setpagedevice } stopped pop }
        ifelse 
        
        FMPColor {
                currentcolorscreen
                        cvlit /orgproc exch def
                                  /organgle exch def 
                                  /orgfreq exch def
                        cvlit /orgbproc exch def
                                  /orgbangle exch def 
                                  /orgbfreq exch def
                        cvlit /orggproc exch def
                                  /orggangle exch def 
                                  /orggfreq exch def
                        cvlit /orgrproc exch def
                                  /orgrangle exch def 
                                  /orgrfreq exch def
                        currentcolortransfer 
                        FrameNegative {
                                1 1 4 { 
                                        pop { 1 exch sub } concatprocs 4 1 roll
                                } for
                                4 copy
                                setcolortransfer
                        } if
                        cvlit /orgxfer exch def
                        cvlit /orgbxfer exch def
                        cvlit /orggxfer exch def
                        cvlit /orgrxfer exch def
        } {
                currentscreen 
                        cvlit /orgproc exch def
                                  /organgle exch def 
                                  /orgfreq exch def
                                  
                currenttransfer 
                FrameNegative {
                        { 1 exch sub } concatprocs
                        dup settransfer
                } if 
                cvlit /orgxfer exch def
        } ifelse
        end 
} def 
/pagesave FMLOCAL
/orgmatrix FMLOCAL
/landscape FMLOCAL
/pwid FMLOCAL
/FMBEGINPAGE { 
        FrameDict begin 
        /pagesave save def
        3.86 setmiterlimit
        /landscape exch 0 ne def
        landscape { 
                90 rotate 0 exch dup /pwid exch def neg translate pop 
        }{
                pop /pwid exch def
        } ifelse
        edown { [-1 0 0 1 pwid 0] concat } if
        0 0 moveto paperwidth 0 lineto paperwidth paperheight lineto 
        0 paperheight lineto 0 0 lineto 1 setgray fill
        xscale yscale scale
        /orgmatrix matrix def
        gsave 
} def 
/FMENDPAGE {
        grestore 
        pagesave restore
        end 
        showpage
        } def 
/FMFONTDEFINE { 
        FrameDict begin
        findfont 
        ReEncode 
        1 index exch 
        definefont 
        FMfonts 3 1 roll 
        put
        end 
        } def 
/FMFILLS {
        FrameDict begin dup
        array /fillvals exch def
        dict /patCache exch def
        end 
        } def 
/FMFILL {
        FrameDict begin
         fillvals 3 1 roll put
        end 
        } def 
/FMNORMALIZEGRAPHICS { 
        newpath
        0.0 0.0 moveto
        1 setlinewidth
        0 setlinecap
        0 0 0 sethsbcolor
        0 setgray 
        } bind def
        /fx FMLOCAL
        /fy FMLOCAL
        /fh FMLOCAL
        /fw FMLOCAL
        /llx FMLOCAL
        /lly FMLOCAL
        /urx FMLOCAL
        /ury FMLOCAL
/FMBEGINEPSF { 
        end 
        /FMEPSF save def 
        /showpage {} def 
% See Adobe's "PostScript Language Reference Manual, 2nd Edition", page 714.
% "...the following operators MUST NOT be used in an EPS file:" (emphasis ours)
        /banddevice {(banddevice) FMBADEPSF} def
        /clear {(clear) FMBADEPSF} def
        /cleardictstack {(cleardictstack) FMBADEPSF} def 
        /copypage {(copypage) FMBADEPSF} def
        /erasepage {(erasepage) FMBADEPSF} def
        /exitserver {(exitserver) FMBADEPSF} def
        /framedevice {(framedevice) FMBADEPSF} def
        /grestoreall {(grestoreall) FMBADEPSF} def
        /initclip {(initclip) FMBADEPSF} def
        /initgraphics {(initgraphics) FMBADEPSF} def
        /initmatrix {(initmatrix) FMBADEPSF} def
        /quit {(quit) FMBADEPSF} def
        /renderbands {(renderbands) FMBADEPSF} def
        /setglobal {(setglobal) FMBADEPSF} def
        /setpagedevice {(setpagedevice) FMBADEPSF} def
        /setshared {(setshared) FMBADEPSF} def
        /startjob {(startjob) FMBADEPSF} def
        /lettertray {(lettertray) FMBADEPSF} def
        /letter {(letter) FMBADEPSF} def
        /lettersmall {(lettersmall) FMBADEPSF} def
        /11x17tray {(11x17tray) FMBADEPSF} def
        /11x17 {(11x17) FMBADEPSF} def
        /ledgertray {(ledgertray) FMBADEPSF} def
        /ledger {(ledger) FMBADEPSF} def
        /legaltray {(legaltray) FMBADEPSF} def
        /legal {(legal) FMBADEPSF} def
        /statementtray {(statementtray) FMBADEPSF} def
        /statement {(statement) FMBADEPSF} def
        /executivetray {(executivetray) FMBADEPSF} def
        /executive {(executive) FMBADEPSF} def
        /a3tray {(a3tray) FMBADEPSF} def
        /a3 {(a3) FMBADEPSF} def
        /a4tray {(a4tray) FMBADEPSF} def
        /a4 {(a4) FMBADEPSF} def
        /a4small {(a4small) FMBADEPSF} def
        /b4tray {(b4tray) FMBADEPSF} def
        /b4 {(b4) FMBADEPSF} def
        /b5tray {(b5tray) FMBADEPSF} def
        /b5 {(b5) FMBADEPSF} def
        FMNORMALIZEGRAPHICS 
        [/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
        fx fw 2 div add fy fh 2 div add  translate
        rotate
        fw 2 div neg fh 2 div neg translate
        fw urx llx sub div fh ury lly sub div scale 
        llx neg lly neg translate 
        /FMdicttop countdictstack 1 add def 
        /FMoptop count def 
        } bind def
/FMENDEPSF {
        count -1 FMoptop {pop pop} for 
        countdictstack -1 FMdicttop {pop end} for 
        FMEPSF restore
        FrameDict begin 
        } bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
         statusdict /manualfeed true put
%%EndFeature
        } bind def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
        paperheight sub abs 16 lt exch 
        paperwidth sub abs 16 lt and
        {/papername exch def} {pop} ifelse
        } bind def
        /papersizedict FMLOCAL
/setpapername { 
        /papersizedict 14 dict def 
        papersizedict begin
        /papername /unknown def 
                /Letter 8.5 inch 11.0 inch pagedimen
                /LetterSmall 7.68 inch 10.16 inch pagedimen
                /Tabloid 11.0 inch 17.0 inch pagedimen
                /Ledger 17.0 inch 11.0 inch pagedimen
                /Legal 8.5 inch 14.0 inch pagedimen
                /Statement 5.5 inch 8.5 inch pagedimen
                /Executive 7.5 inch 10.0 inch pagedimen
                /A3 11.69 inch 16.5 inch pagedimen
                /A4 8.26 inch 11.69 inch pagedimen
                /A4Small 7.47 inch 10.85 inch pagedimen
                /B4 10.125 inch 14.33 inch pagedimen
                /B5 7.16 inch 10.125 inch pagedimen
        end
        } bind def
/papersize {
        papersizedict begin
                /Letter {lettertray letter} def
                /LetterSmall {lettertray lettersmall} def
                /Tabloid {11x17tray 11x17} def
                /Ledger {ledgertray ledger} def
                /Legal {legaltray legal} def
                /Statement {statementtray statement} def
                /Executive {executivetray executive} def
                /A3 {a3tray a3} def
                /A4 {a4tray a4} def
                /A4Small {a4tray a4small} def
                /B4 {b4tray b4} def
                /B5 {b5tray b5} def
                /unknown {unknown} def
        papersizedict dup papername known {papername} {/unknown} ifelse get
        end
        statusdict begin stopped end 
        } bind def
/manualpapersize {
        papersizedict begin
                /Letter {letter} def
                /LetterSmall {lettersmall} def
                /Tabloid {11x17} def
                /Ledger {ledger} def
                /Legal {legal} def
                /Statement {statement} def
                /Executive {executive} def
                /A3 {a3} def
                /A4 {a4} def
                /A4Small {a4small} def
                /B4 {b4} def
                /B5 {b5} def
                /unknown {unknown} def
        papersizedict dup papername known {papername} {/unknown} ifelse get
        end
        stopped 
        } bind def
/desperatepapersize {
        statusdict /setpageparams known
                {
                paperwidth paperheight 0 1 
                statusdict begin
                {setpageparams} stopped 
                end
                } {true} ifelse 
        } bind def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
        dup 
        length 
        dict begin 
        {
        1 index /FID ne 
                {def} 
                {pop pop} ifelse 
        } forall 
        0 eq {/Encoding DiacriticEncoding def} if 
        currentdict 
        end 
        } bind def
FMPColor 
        
        {
        /BEGINBITMAPCOLOR { 
                BITMAPCOLOR} def
        /BEGINBITMAPCOLORc { 
                BITMAPCOLORc} def
        /BEGINBITMAPTRUECOLOR { 
                BITMAPTRUECOLOR } def
        /BEGINBITMAPTRUECOLORc { 
                BITMAPTRUECOLORc } def
        }
        
        {
        /BEGINBITMAPCOLOR { 
                BITMAPGRAY} def
        /BEGINBITMAPCOLORc { 
                BITMAPGRAYc} def
        /BEGINBITMAPTRUECOLOR { 
                BITMAPTRUEGRAY } def
        /BEGINBITMAPTRUECOLORc { 
                BITMAPTRUEGRAYc } def
        }
ifelse
/K { 
        FMPrintAllColorsAsBlack {
                dup 1 eq 2 index 1 eq and 3 index 1 eq and not
                        {7 {pop} repeat 0 0 0 1 0 0 0} if
        } if 
        FrameCurColors astore 
        pop combineColor
} bind def
/graymode true def
        /bwidth FMLOCAL
        /bpside FMLOCAL
        /bstring FMLOCAL
        /onbits FMLOCAL
        /offbits FMLOCAL
        /xindex FMLOCAL
        /yindex FMLOCAL
        /x FMLOCAL
        /y FMLOCAL
/setPatternMode {
        FMLevel1 {
                /bwidth  exch def
                /bpside  exch def
                /bstring exch def
                /onbits 0 def  /offbits 0 def
                freq sangle landscape {90 add} if 
                        {/y exch def
                         /x exch def
                         /xindex x 1 add 2 div bpside mul cvi def
                         /yindex y 1 add 2 div bpside mul cvi def
                         bstring yindex bwidth mul xindex 8 idiv add get
                         1 7 xindex 8 mod sub bitshift and 0 ne FrameNegative {not} if
                         {/onbits  onbits  1 add def 1}
                         {/offbits offbits 1 add def 0}
                         ifelse
                        }
                        setscreen
                offbits offbits onbits add div FrameNegative {1.0 exch sub} if
                /FrameCurGray exch def
        } { 
                pop pop
                dup patCache exch known {
                        patCache exch get
                } { 
                        dup
                        patDict /bstring 3 -1 roll put
                        patDict 
                        9 PatFreq screenIndex get div dup matrix scale
                        makepattern
                        dup 
                        patCache 4 -1 roll 3 -1 roll put
                } ifelse
                /FrameCurGray 0 def
                /FrameCurPat exch def
        } ifelse
        /graymode false def
        combineColor
} bind def
/setGrayScaleMode {
        graymode not {
                /graymode true def
                FMLevel1 {
                        setCurrentScreen
                } if
        } if
        /FrameCurGray exch def
        combineColor
} bind def
/normalize {
        transform round exch round exch itransform
        } bind def
/dnormalize {
        dtransform round exch round exch idtransform
        } bind def
/lnormalize { 
        0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
        } bind def
/H { 
        lnormalize setlinewidth
        } bind def
/Z {
        setlinecap
        } bind def
        
/PFill {
        graymode FMLevel1 or not {
                gsave 1 setgray eofill grestore
        } if
} bind def
/PStroke {
        graymode FMLevel1 or not {
                gsave 1 setgray stroke grestore
        } if
        stroke
} bind def
        /fillvals FMLOCAL
/X { 
        fillvals exch get
        dup type /stringtype eq
        {8 1 setPatternMode} 
        {setGrayScaleMode}
        ifelse
        } bind def
/V { 
        PFill gsave eofill grestore
        } bind def
/Vclip {
        clip
        } bind def
/Vstrk {
        currentlinewidth exch setlinewidth PStroke setlinewidth
        } bind def
/N { 
        PStroke
        } bind def
/Nclip {
        strokepath clip newpath
        } bind def
/Nstrk {
        currentlinewidth exch setlinewidth PStroke setlinewidth
        } bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
        /n FMLOCAL
/L { 
        /n exch def
        newpath
        normalize
        moveto 
        2 1 n {pop normalize lineto} for
        } bind def
/Y { 
        L 
        closepath
        } bind def
        /x1 FMLOCAL
        /x2 FMLOCAL
        /y1 FMLOCAL
        /y2 FMLOCAL
/R { 
        /y2 exch def
        /x2 exch def
        /y1 exch def
        /x1 exch def
        x1 y1
        x2 y1
        x2 y2
        x1 y2
        4 Y 
        } bind def
        /rad FMLOCAL
/rarc 
        {rad 
         arcto
        } bind def
/RR { 
        /rad exch def
        normalize
        /y2 exch def
        /x2 exch def
        normalize
        /y1 exch def
        /x1 exch def
        mark
        newpath
        {
        x1 y1 rad add moveto
        x1 y2 x2 y2 rarc
        x2 y2 x2 y1 rarc
        x2 y1 x1 y1 rarc
        x1 y1 x1 y2 rarc
        closepath
        } stopped {x1 y1 x2 y2 R} if 
        cleartomark
        } bind def
/RRR { 
        /rad exch def
        normalize /y4 exch def /x4 exch def
        normalize /y3 exch def /x3 exch def
        normalize /y2 exch def /x2 exch def
        normalize /y1 exch def /x1 exch def
        newpath
        normalize moveto 
        mark
        {
        x2 y2 x3 y3 rarc
        x3 y3 x4 y4 rarc
        x4 y4 x1 y1 rarc
        x1 y1 x2 y2 rarc
        closepath
        } stopped
         {x1 y1 x2 y2 x3 y3 x4 y4 newpath moveto lineto lineto lineto closepath} if
        cleartomark
        } bind def
/C { 
        grestore
        gsave
        R 
        clip
        setCurrentScreen
} bind def
/CP { 
        grestore
        gsave
        Y 
        clip
        setCurrentScreen
} bind def
        /FMpointsize FMLOCAL
/F { 
        FMfonts exch get
        FMpointsize scalefont
        setfont
        } bind def
/Q { 
        /FMpointsize exch def
        F 
        } bind def
/T { 
        moveto show
        } bind def
/RF { 
        rotate
        0 ne {-1 1 scale} if
        } bind def
/TF { 
        gsave
        moveto 
        RF
        show
        grestore
        } bind def
/P { 
        moveto
        0 32 3 2 roll widthshow
        } bind def
/PF { 
        gsave
        moveto 
        RF
        0 32 3 2 roll widthshow
        grestore
        } bind def
/S { 
        moveto
        0 exch ashow
        } bind def
/SF { 
        gsave
        moveto
        RF
        0 exch ashow
        grestore
        } bind def
/B { 
        moveto
        0 32 4 2 roll 0 exch awidthshow
        } bind def
/BF { 
        gsave
        moveto
        RF
        0 32 4 2 roll 0 exch awidthshow
        grestore
        } bind def
/G { 
        gsave
        newpath
        normalize translate 0.0 0.0 moveto 
        dnormalize scale 
        0.0 0.0 1.0 5 3 roll arc 
        closepath 
        PFill fill
        grestore
        } bind def
/Gstrk {
        savematrix
    newpath
    2 index 2 div add exch 3 index 2 div sub exch 
    normalize 2 index 2 div sub exch 3 index 2 div add exch 
    translate
    scale 
    0.0 0.0 1.0 5 3 roll arc 
    restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/Gclip { 
        newpath
        savematrix
        normalize translate 0.0 0.0 moveto 
        dnormalize scale 
        0.0 0.0 1.0 5 3 roll arc 
        closepath 
        clip newpath
        restorematrix
        } bind def
/GG { 
        gsave
        newpath
        normalize translate 0.0 0.0 moveto 
        rotate 
        dnormalize scale 
        0.0 0.0 1.0 5 3 roll arc 
        closepath
        PFill
        fill
        grestore
        } bind def
/GGclip { 
        savematrix
        newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
        clip newpath
        restorematrix
        } bind def
/GGstrk { 
        savematrix
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
        restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
        } bind def
/A { 
        gsave
        savematrix
        newpath
        2 index 2 div add exch 3 index 2 div sub exch 
        normalize 2 index 2 div sub exch 3 index 2 div add exch 
        translate 
        scale 
        0.0 0.0 1.0 5 3 roll arc 
        restorematrix
        PStroke
        grestore
        } bind def
/Aclip {
        newpath
        savematrix
        normalize translate 0.0 0.0 moveto 
        dnormalize scale 
        0.0 0.0 1.0 5 3 roll arc 
        closepath 
        strokepath clip newpath
        restorematrix
} bind def
/Astrk {
        Gstrk
} bind def
/AA { 
        gsave
        savematrix
        newpath
        
        3 index 2 div add exch 4 index 2 div sub exch 
        
        normalize 3 index 2 div sub exch 4 index 2 div add exch
        translate 
        rotate 
        scale 
        0.0 0.0 1.0 5 3 roll arc 
        restorematrix
        PStroke
        grestore
        } bind def
/AAclip {
        savematrix
        newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
        strokepath clip newpath
        restorematrix
} bind def
/AAstrk {
        GGstrk
} bind def
        /x FMLOCAL
        /y FMLOCAL
        /w FMLOCAL
        /h FMLOCAL
        /xx FMLOCAL
        /yy FMLOCAL
        /ww FMLOCAL
        /hh FMLOCAL
        /FMsaveobject FMLOCAL
        /FMoptop FMLOCAL
        /FMdicttop FMLOCAL
/BEGINPRINTCODE { 
        /FMdicttop countdictstack 1 add def 
        /FMoptop count 7 sub def 
        /FMsaveobject save def
        userdict begin 
        /showpage {} def 
        FMNORMALIZEGRAPHICS 
        3 index neg 3 index neg translate
        } bind def
/ENDPRINTCODE {
        count -1 FMoptop {pop pop} for 
        countdictstack -1 FMdicttop {pop end} for 
        FMsaveobject restore 
        } bind def
/gn { 
        0 
        {       46 mul 
                cf read pop 
                32 sub 
                dup 46 lt {exit} if 
                46 sub add 
                } loop
        add 
        } bind def
        /str FMLOCAL
/cfs { 
        /str sl string def 
        0 1 sl 1 sub {str exch val put} for 
        str def 
        } bind def
/ic [ 
        0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
        0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
        0
        {0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
        {10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
        {19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
        {13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
        {4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
        {13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
        {7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
        {0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
        {10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
        ] def
        /sl FMLOCAL
        /val FMLOCAL
        /ws FMLOCAL
        /im FMLOCAL
        /bs FMLOCAL
        /cs FMLOCAL
        /len FMLOCAL
        /pos FMLOCAL
/ms { 
        /sl exch def 
        /val 255 def 
        /ws cfs 
        /im cfs 
        /val 0 def 
        /bs cfs 
        /cs cfs 
        } bind def
400 ms 
/ip { 
        is 
        0 
        cf cs readline pop 
        {       ic exch get exec 
                add 
                } forall 
        pop 
        
        } bind def
/rip { 
           
          
          bis ris copy pop 
      is
      0
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
          pop pop 
          ris gis copy pop 
          dup is exch 
          
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
          pop pop
          gis bis copy pop 
          dup add is exch 
          
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop 
      
      } bind def
/wh { 
        /len exch def 
        /pos exch def 
        ws 0 len getinterval im pos len getinterval copy pop
        pos len 
        } bind def
/bl { 
        /len exch def 
        /pos exch def 
        bs 0 len getinterval im pos len getinterval copy pop
        pos len 
        } bind def
/s1 1 string def
/fl { 
        /len exch def 
        /pos exch def 
        /val cf s1 readhexstring pop 0 get def
        pos 1 pos len add 1 sub {im exch val put} for
        pos len 
        } bind def
/hx { 
        3 copy getinterval 
        cf exch readhexstring pop pop 
        } bind def
        /h FMLOCAL
        /w FMLOCAL
        /d FMLOCAL
        /lb FMLOCAL
        /bitmapsave FMLOCAL
        /is FMLOCAL
        /cf FMLOCAL
/wbytes { 
      dup dup
      24 eq { pop pop 3 mul }
      { 8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse } ifelse
        } bind def
/BEGINBITMAPBWc { 
        1 {} COMMONBITMAPc
        } bind def
/BEGINBITMAPGRAYc { 
        8 {} COMMONBITMAPc
        } bind def
/BEGINBITMAP2BITc { 
        2 {} COMMONBITMAPc
        } bind def
/COMMONBITMAPc { 
                 
        /r exch def
        /d exch def
        gsave
        
        3 index 2 div add exch  
        4 index 2 div add exch  
        translate               
        rotate                  
        1 index 2 div neg       
        1 index 2 div neg       
        translate               
        scale                   
        /h exch def /w exch def
        /lb w d wbytes def 
        sl lb lt {lb ms} if 
        /bitmapsave save def 
        r                    
        /is im 0 lb getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h d [w 0 0 h neg 0 h] 
        {ip} image 
        bitmapsave restore 
        grestore
        } bind def
/BEGINBITMAPBW { 
        1 {} COMMONBITMAP
        } bind def
/BEGINBITMAPGRAY { 
        8 {} COMMONBITMAP
        } bind def
/BEGINBITMAP2BIT { 
        2 {} COMMONBITMAP
        } bind def
/COMMONBITMAP { 
        /r exch def
        /d exch def
        gsave
        
        3 index 2 div add exch  
        4 index 2 div add exch  
        translate               
        rotate                  
        1 index 2 div neg       
        1 index 2 div neg       
        translate               
        scale                   
        /h exch def /w exch def
        /bitmapsave save def 
        r                    
        /is w d wbytes string def
        /cf currentfile def 
        w h d [w 0 0 h neg 0 h] 
        {cf is readhexstring pop} image
        bitmapsave restore 
        grestore
        } bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
        /gryt FMLOCAL
        /blut FMLOCAL
        /grnt FMLOCAL
        /redt FMLOCAL
        /indx FMLOCAL
        /cynu FMLOCAL
        /magu FMLOCAL
        /yelu FMLOCAL
        /k FMLOCAL
        /u FMLOCAL
FMLevel1 {
/colorsetup {
        currentcolortransfer
        /gryt exch def
        /blut exch def
        /grnt exch def
        /redt exch def
        0 1 255 {
                /indx exch def
                /cynu 1 red indx get 255 div sub def
                /magu 1 green indx get 255 div sub def
                /yelu 1 blue indx get 255 div sub def
                /k cynu magu min yelu min def
                /u k currentundercolorremoval exec def
%               /u 0 def
                nredt indx 1 0 cynu u sub max sub redt exec put
                ngreent indx 1 0 magu u sub max sub grnt exec put
                nbluet indx 1 0 yelu u sub max sub blut exec put
                ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
        } for
        {255 mul cvi nredt exch get}
        {255 mul cvi ngreent exch get}
        {255 mul cvi nbluet exch get}
        {255 mul cvi ngrayt exch get}
        setcolortransfer
        {pop 0} setundercolorremoval
        {} setblackgeneration
        } bind def
}
{
/colorSetup2 {
        [ /Indexed /DeviceRGB 255 
                {dup red exch get 255 div 
                 exch dup green exch get 255 div 
                 exch blue exch get 255 div}
        ] setcolorspace
} bind def
} ifelse
        /tran FMLOCAL
/fakecolorsetup {
        /tran 256 string def
        0 1 255 {/indx exch def 
                tran indx
                red indx get 77 mul
                green indx get 151 mul
                blue indx get 28 mul
                add add 256 idiv put} for
        currenttransfer
        {255 mul cvi tran exch get 255.0 div}
        exch concatprocs settransfer
} bind def
/BITMAPCOLOR { 
        /d 8 def
        gsave
        
        3 index 2 div add exch  
        4 index 2 div add exch  
        translate               
        rotate                  
        1 index 2 div neg       
        1 index 2 div neg       
        translate               
        scale                   
        /h exch def /w exch def
        /bitmapsave save def
        FMLevel1 {      
                colorsetup
                /is w d wbytes string def
                /cf currentfile def 
                w h d [w 0 0 h neg 0 h] 
                {cf is readhexstring pop} {is} {is} true 3 colorimage 
        } {
                colorSetup2
                /is w d wbytes string def
                /cf currentfile def 
                7 dict dup begin
                        /ImageType 1 def
                        /Width w def
                        /Height h def
                        /ImageMatrix [w 0 0 h neg 0 h] def
                        /DataSource {cf is readhexstring pop} bind def
                        /BitsPerComponent d def
                        /Decode [0 255] def
                end image       
        } ifelse
        bitmapsave restore 
        grestore
        } bind def
/BITMAPCOLORc { 
        /d 8 def
        gsave
        
        3 index 2 div add exch  
        4 index 2 div add exch  
        translate               
        rotate                  
        1 index 2 div neg       
        1 index 2 div neg       
        translate               
        scale                   
        /h exch def /w exch def
        /lb w d wbytes def 
        sl lb lt {lb ms} if 
        /bitmapsave save def 
        FMLevel1 {      
                colorsetup
                /is im 0 lb getinterval def 
                ws 0 lb getinterval is copy pop 
                /cf currentfile def 
                w h d [w 0 0 h neg 0 h] 
                {ip} {is} {is} true 3 colorimage
        } {
                colorSetup2
                /is im 0 lb getinterval def 
                ws 0 lb getinterval is copy pop 
                /cf currentfile def 
                7 dict dup begin
                        /ImageType 1 def
                        /Width w def
                        /Height h def
                        /ImageMatrix [w 0 0 h neg 0 h] def
                        /DataSource {ip} bind def
                        /BitsPerComponent d def
                        /Decode [0 255] def
                end image       
        } ifelse
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUECOLORc { 
        /d 24 def
        gsave
        
        3 index 2 div add exch  
        4 index 2 div add exch  
        translate               
        rotate                  
        1 index 2 div neg       
        1 index 2 div neg       
        translate               
        scale                   
        /h exch def /w exch def
        /lb w d wbytes def 
        sl lb lt {lb ms} if 
        /bitmapsave save def 
        
        /is im 0 lb getinterval def     
        /ris im 0 w getinterval def     
        /gis im w w getinterval def     
        /bis im w 2 mul w getinterval def 
        
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris} {gis} {bis} true 3 colorimage
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUECOLOR { 
        gsave
                
                3 index 2 div add exch  
                4 index 2 div add exch  
                translate               
                rotate                  
                1 index 2 div neg       
                1 index 2 div neg       
                translate               
                scale                   
                /h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
        /d 24 def
        gsave
        
        3 index 2 div add exch  
        4 index 2 div add exch  
        translate               
        rotate                  
        1 index 2 div neg       
        1 index 2 div neg       
        translate               
        scale                   
        /h exch def /w exch def
        /lb w d wbytes def 
        sl lb lt {lb ms} if 
        /bitmapsave save def 
        
        /is im 0 lb getinterval def     
        /ris im 0 w getinterval def     
        /gis im w w getinterval def     
        /bis im w 2 mul w getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris gis bis w gray} image
        bitmapsave restore 
        grestore
        } bind def
/ww FMLOCAL
/r FMLOCAL
/g FMLOCAL
/b FMLOCAL
/i FMLOCAL
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
                        b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
                
                3 index 2 div add exch  
                4 index 2 div add exch  
                translate               
                rotate                  
                1 index 2 div neg       
                1 index 2 div neg       
                translate               
                scale                   
                /h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop w gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
        8 {fakecolorsetup} COMMONBITMAP
        } bind def
/BITMAPGRAYc { 
        8 {fakecolorsetup} COMMONBITMAPc
        } bind def
/ENDBITMAP {
        } bind def
end 
        /ALDsave FMLOCAL
        /ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
        /ALDsave save def
         savematrix
         ALDmatrix setmatrix
        } bind def
/InALD {
         restorematrix
        } bind def
/DoneALD {
         ALDsave restore
        } bind def
/I { setdash } bind def
/J { [] 0 setdash } bind def
%%EndProlog
%%BeginSetup
(4.0) FMVERSION
1 1 0 0 612 792 0 1 7 FMDOCUMENT
0 0 /Times-Roman FMFONTDEFINE
1 0 /Times-Bold FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 0.1 FMFILL
2 0.3 FMFILL
3 0.5 FMFILL
4 0.7 FMFILL
5 0.9 FMFILL
6 0.97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 0.9 FMFILL
18 0.7 FMFILL
19 0.5 FMFILL
20 0.3 FMFILL
21 0.1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "1" 1
%%BeginPaperSize: Letter
%%EndPaperSize
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
J
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(Polyanna: A Sorcerer) 108 42.5 T
(-based Symbolic Manipulation of Polynomials) 176.71 42.5 T
(July 18, 1995) 326.05 42.5 T
(1) 536 42.5 T
0 24 Q
(Polyanna: A Sorcerer) 140.6 704 T
(-based Symbolic) 346.74 704 T
(Manipulation of Polynomials) 183.32 674 T
1 12 Q
(In this paper) 108 634 T
(, we describe Polyanna--a simple symbolic calculator which can add a) 172.91 634 T
(multiply polynomials. In addition to being a useful tool, polyanna serves as an) 108 613 T
(illustration of some of Sor) 108 592 T
(cer) 240.44 592 T
(er) 256.21 592 T
(\325) 267.08 592 T
(s capabilities.) 270.64 592 T
1 16 Q
(1.0  Intr) 108 544.33 T
(oduction.) 163.26 544.33 T
0 12 Q
 -0.11 (In this paper we illustrate the how the powerful tree walking and manipulating features of) 108 517 P
(SORCERER can be used to simply and almost automatically create applications which) 108 503 T
 -0.13 (would require tedious and intricate programming if done by hand. Even top-\337ight proram-) 108 489 P
 -0.16 (mers can \336nd themselves logging many hours with their favorite debuggers when attempt-) 108 475 P
(ing to write the kind of recursive, pattern-matching code which crops up in applications) 108 461 T
(like optimizing compilers and Arti\336cial Intelligence programs.) 108 447 T
(Using SORCERER has much the same \337avor as using a compiler compiler) 108 421 T
(, and program-) 467.83 421 T
 -0.11 (ers who are already pro\336cient with ANTLR will, in a few days time, \336nd themselves tack-) 108 407 P
(ling with ease projects which they might never have done otherwise.) 108 393 T
1 16 Q
(2.0  Featur) 108 352.33 T
(es of Polyanna) 181.92 352.33 T
0 12 Q
 -0.11 (     Before we dive into the details of interfacing ANTLR and SORCERER, let\325) 108 325 P
 -0.11 (s get a feel) 485.81 325 P
 -0.04 (for the kind of tool we would like to create. W) 108 311 P
 -0.04 (e\325ll call it Polyanna, because it simple poly-) 329.62 311 P
(nomial manipulator) 108 297 T
(. W) 201.67 297 T
(e\325d like it to be able to perform operations like the following:) 218.04 297 T
1 10 Q
(> expand\050\050x^2 + 2*x + 6\051 * \0503*x + 7\051\051;) 108 278.33 T
(    3       2) 108 262.33 T
(3 x  + 13 x  + 32 x + 42) 108 246.33 T
(> int\0505 * x^2 + 6, x\051;) 108 230.33 T
(      3) 108 214.33 T
(5/3  X + 6 x) 108 198.33 T
(> diff\050\050x^3 + 6*x^2+17\051, x\051;) 108 182.33 T
(   2) 108 150.33 T
(3 x  + 12 x) 108 134.33 T
0 12 Q
(There are 3 steps which must be done to execute the kind of commands which are illus-) 108 109 T
(trated above:) 108 95 T
(1.) 108 75 T
(Use ANTLR to read in a command, and create an abstract syntax tree for it.) 121.75 75 T
FMENDPAGE
%%EndPage: "1" 1
%%Page: "2" 2
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(Polyanna: A Sorcerer) 108 42.5 T
(-based Symbolic Manipulation of Polynomials) 176.71 42.5 T
(July 18, 1995) 326.05 42.5 T
(2) 536 42.5 T
0 12 Q
(2.) 108 712 T
(Use SORCERER to walk the tree in order to determine the proper actions to do.) 121.75 712 T
(3.) 108 692 T
(Use SORCERER to manipulate the resulting polynomials in such a was as to execute) 121.75 692 T
(the command.) 121.75 678 T
1 16 Q
(3.0  A Step-by-Step Description of the Cr) 108 637.33 T
(eation of Polyanna.) 387.68 637.33 T
0 12 Q
(In this section, we describe in a rather exhaustive fashion the steps required to create an) 108 610 T
(application which uses sorcerer) 108 596 T
(. W) 258.3 596 T
(e hope that the detail does not frighten away potential) 274.67 596 T
(users of Sorcerer) 108 582 T
(--in fact this much detail should make it easier to use. Conversely) 189.06 582 T
(, we) 502.91 582 T
(hope we do not bore the more advanced users of PCCTS with excessive detail.) 108 568 T
(W) 108 542 T
(ith these caveats in mind, we proceed to describe in detail the creation of polyanna:) 118.85 542 T
1 14 Q
(3.1  Cr) 108 508.67 T
(eate dir) 148.57 508.67 T
(ectory for the pr) 193.81 508.67 T
(oject.) 291.9 508.67 T
0 12 Q
(In our case, we use a directory named \322poly\323 to hold all of the \336les which are assoticated) 108 482 T
(with this project.) 108 468 T
1 14 Q
(3.2  Determine what tokens ar) 108 434.67 T
(e necessary) 287.38 434.67 T
(.) 353.87 434.67 T
0 12 Q
(Looking over the example interaction above, we see that polynomials contain + and *, as) 108 408 T
(well as variable names and numbers. An invaluable source of token de\336nitions comes for) 108 394 T
 -0.43 (free in the example ansi C grammar available from most ftp sites which carry PCCTS. The) 108 380 P
 -0.13 (token de\336nitions for handling \337oating-point numbers was lifted directly) 108 366 P
 -0.13 (. The other tokens) 450.86 366 P
(are self-explanatory) 108 352 T
(.) 202.85 352 T
1 10 Q
(#token INT \322[1-9][0-9]*\323) 108 333.33 T
(#token OPENP \322\134\050\322) 108 317.33 T
(#token CLOSP \322\134\051\323) 108 301.33 T
(#token V) 108 285.33 T
(AR \322[a-zA-Z][a-zA-Z]*\323) 145.32 285.33 T
(#token FLOA) 108 269.33 T
(T) 166.43 269.33 T
(ONE \322\050[0-9]+.[0-9]* | [0-9]*.[0-9]+\051 {[eE]{[\134-\134+]}[0-9]+} {[fFlL]}\323) 172.92 269.33 T
(#token FLOA) 108 253.33 T
(TTWO \322[0-9]+ [eE]{[\134-\134+]}[0-9]+ {[fFlL]}\323) 166.43 253.33 T
(#token PLUS \322\134+\323) 108 237.33 T
(#token MINUS \322\134-\323) 108 221.33 T
(#token MUL) 108 205.33 T
(T \322\134*\323) 161.8 205.33 T
(#token EXPN \322\134^\323) 108 189.33 T
1 14 Q
(3.3  W) 108 156.67 T
(rite the AST) 146.25 156.67 T
(.h File) 219.09 156.67 T
0 12 Q
(polyanna uses the built-in abstract syntax tree creation capabilities of PCCTS. Therefore,) 108 130 T
(we must create an AST) 108 116 T
(.h which contains the things which ANTLR is looking for) 219.08 116 T
(. Useful) 495.74 116 T
(templates for building your own AST) 108 102 T
(.h \336les can be found in the testcpp/ directory of the) 287.44 102 T
(PCCTS distribution directory) 108 88 T
(. The exact contents of our AST) 248.57 88 T
(.h re\337ects the fact that we) 401.32 88 T
FMENDPAGE
%%EndPage: "2" 2
%%Page: "3" 3
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(Polyanna: A Sorcerer) 108 42.5 T
(-based Symbolic Manipulation of Polynomials) 176.71 42.5 T
(July 18, 1995) 326.05 42.5 T
(3) 536 42.5 T
0 12 Q
(want not only ANTLR to automatically create our abstract syntax trees, but also that we) 108 712 T
(wish SORCERER to manipulate them.) 108 698 T
(W) 108 672 T
(e de\336ne the class AST as inheriting from the supplied ASTBase class. This automati-) 118.37 672 T
 -0.06 (cally gives us the \336elds which are necessary in order to have PCCTS automatically create) 108 658 P
(the AST) 108 644 T
(s for us:) 147.49 644 T
1 10 Q
(                                            class AST) 108 625.33 T
(: public ASTBase {) 259.21 625.33 T
0 12 Q
 -0.09 (Next we must put in a type\050\051 function in for purposes of communicating with SORERER.) 108 600 P
(The type\050\051 function returns an in which is used to determine the token which this AST) 108 586 T
(node is associated with:) 108 572 T
1 10 Q
(pr) 108 553.33 T
(otected:) 117.82 553.33 T
(   int _type;) 108 537.33 T
(public) 108 521.33 T
( int type\050\051{) 108 505.33 T
(      r) 108 489.33 T
(eturn _type;) 127.26 489.33 T
(}) 108 473.33 T
0 12 Q
(Now we must write the constructor for the AST class.   The purpose of the constructor is) 108 448 T
 -0.45 (to tell PCCTS how to create an AST node from an ANTLR) 108 434 P
 -0.45 (T) 387.32 434 P
 -0.45 (oken. It must look at the token) 393.81 434 P
(which was scanned, and set the _type \336eld accordingly:) 108 420 T
1 10 Q
( AST\050ANTLR) 108 401.33 T
(T) 167.93 401.33 T
(okenBase *t\051{) 173.68 401.33 T
(      _type=t->getT) 108 385.33 T
(ype\050\051;) 183.09 385.33 T
(       switch\050_type\051{) 108 369.33 T
(      case INT) 108 353.33 T
(:) 160.31 353.33 T
(             numb=atof\050t->getT) 108 337.33 T
(ext\050\051\051;) 222.08 337.33 T
( _type=FLOA) 138 321.33 T
(T) 196.57 321.33 T
(ONE;) 203.06 321.33 T
( br) 140.5 305.33 T
(eak;) 152.82 305.33 T
(      case FLOA) 108 289.33 T
(T) 170.31 289.33 T
(ONE:) 176.8 289.33 T
( numb=atof\050t->getT) 143 273.33 T
(ext\050\051\051;) 227.08 273.33 T
( br) 145.5 257.33 T
(eak;) 157.82 257.33 T
(      case FLOA) 108 241.33 T
(TTWO:) 170.31 241.33 T
( numb=atof\050t->getT) 145.5 225.33 T
(ext\050\051\051;) 229.58 225.33 T
( _type=FLOA) 145.5 209.33 T
(T) 204.07 209.33 T
(ONE;) 210.56 209.33 T
( br) 148 193.33 T
(eak;) 160.32 193.33 T
(      default:) 108 177.33 T
(                text = new char[strlen\050t->getT) 108 161.33 T
(ext\050\051\051+1];) 275.94 161.33 T
(                 str) 108 145.33 T
(cpy\050text, t->getT) 161.98 145.33 T
(ext\050\051\051;) 232.29 145.33 T
( _type=NOT_A) 150.5 129.33 T
(T_T) 215.18 129.33 T
(OKEN;) 233.34 129.33 T
( br) 150.5 113.33 T
(eak;) 162.82 113.33 T
(    }) 108 97.33 T
(}) 108 81.33 T
FMENDPAGE
%%EndPage: "3" 3
%%Page: "4" 4
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(Polyanna: A Sorcerer) 108 42.5 T
(-based Symbolic Manipulation of Polynomials) 176.71 42.5 T
(July 18, 1995) 326.05 42.5 T
(4) 536 42.5 T
0 12 Q
(And as a \336nal touch to our AST class, we include a preorder_action\050\051 function for pur-) 108 686 T
(poses of printing out our AST) 108 672 T
(s:) 250.82 672 T
1 10 Q
(void pr) 108 653.33 T
(eorder_action\050\051 {) 138.66 653.33 T
(      switch\050_type\051{) 108 637.33 T
(      case FLOA) 108 621.33 T
(T) 170.31 621.33 T
(ONE:) 176.8 621.33 T
( printf\050\322%f \322, numb\051;) 108 605.33 T
( br) 108 589.33 T
(eak;) 120.32 589.33 T
(      default:) 108 573.33 T
( printf\050\322%s \322, text\051;) 108 557.33 T
( br) 108 541.33 T
(eak;) 120.32 541.33 T
(  }) 108 525.33 T
(}) 108 509.33 T
1 14 Q
(3.4  W) 108 476.67 T
(rite the ANTLR Grammar for Recognizing Polynomials) 146.25 476.67 T
0 12 Q
 -0.33 (Polynomials have a simple structure--which means that fortunately a simple grammar will) 108 450 P
(suf) 108 436 T
(\336ce to parse them:) 122.45 436 T
1 10 Q
(class poly_parser {) 108 417.33 T
(polynomial:) 108 401.33 T
(term \050MUL) 108 385.33 T
(T^ term\051*) 156.78 385.33 T
(;) 108 369.33 T
(term:) 108 353.33 T
(V) 108 337.33 T
(AR {EXPN^ constant}) 113.93 337.33 T
(     |) 108 321.33 T
(constant {PLUS^ term}) 125.2 321.33 T
(;) 108 305.33 T
(constant: INT) 108 289.33 T
( | FLOA) 108 273.33 T
(T) 142.24 273.33 T
(ONE) 148.73 273.33 T
( | FLOA) 108 257.33 T
(TWO) 142.24 257.33 T
(;) 108 241.33 T
(}) 108 225.33 T
1 14 Q
(3.5  Cr) 108 192.67 T
(eate the Make\336le Using genmk) 148.57 192.67 T
0 12 Q
(genmk is an extremely useful program which takes care of much of the hassles of using) 108 166 T
(PCCTS. However) 108 152 T
(, it is not yet SORCERER-aware, so we must post-edit its output. How-) 194.18 152 T
(ever) 108 138 T
(, by using it we automate as much of our job as possible. Here is the command line) 128.17 138 T
(which I used to create the polyanna Make\336le:) 108 124 T
1 F
 -0.43 (genmk -CC -class poly_parser -pr) 108 98 P
 -0.43 (oject polyman poly_grammar) 279.38 98 P
 -0.43 (.g > Make\336le   genmk) 429.4 98 P
(-CC -pr) 108 84 T
(oject polyman -class poly_parser poly_grammar) 148.1 84 T
(.g -tr) 394.31 84 T
(ees >Make\336le) 419.41 84 T
FMENDPAGE
%%EndPage: "4" 4
%%Page: "5" 5
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(Polyanna: A Sorcerer) 108 42.5 T
(-based Symbolic Manipulation of Polynomials) 176.71 42.5 T
(July 18, 1995) 326.05 42.5 T
(5) 536 42.5 T
0 12 Q
(The \336rst patch which needs to be made to the output is to tell the Make\336le where to \336nd) 108 712 T
(the PCCTS header and library \336les. Y) 108 698 T
(ou\325ll have to change the PCCTS macro to point to) 289.12 698 T
(the PCCTS home directory) 108 684 T
(.) 237.55 684 T
(The second change which is necessary for this project is to tell ANTLR that we need a) 108 658 T
(lookahead of two and we want interactive input:) 108 644 T
(Change:) 108 618 T
1 F
(AFLAGS = -CC -gt) 151 618 T
0 F
(to   :) 253.82 618 T
1 F
(AFLAGS = -CC -gt -k 2 -g) 278.5 618 T
0 F
(k) 413.99 618 T
1 14 Q
(3.6  W) 108 584.67 T
(rite the Sor) 146.25 584.67 T
(cer) 213.64 584.67 T
(er \336le) 232.04 584.67 T
0 12 Q
 -0.26 (Because we want to keep the ANTLR grammar and the SORCERER manipulator in sync,) 108 558 P
(we have to make sure the same tokens are used by both ANTLR and SORCERER. This) 108 544 T
 -0.25 (can be accomplished by including the tokens in the #header directive. W) 108 530 P
 -0.25 (e also want to use) 452.92 530 P
(the same AST) 108 516 T
(s; therefore we include the AST) 175.15 516 T
(.h which we wrote above as well:) 327.23 516 T
1 10 Q
(#header) 108 497.33 T
(<<) 108 481.33 T
(#include <stdio.h>) 108 465.33 T
(#include \322tokens.h\323) 108 449.33 T
(/* Interface with the ANTLR AST) 108 417.33 T
(s */) 252.9 417.33 T
(#include \322AST) 108 401.33 T
(.h\323) 170.33 401.33 T
(typedef AST SORAST) 108 385.33 T
(;) 203.38 385.33 T
(>>) 108 369.33 T
0 12 Q
(The rest of our SORCERER \336le will contain the various actions which let us manipulate) 108 344 T
(the polynomials.) 108 330 T
1 14 Q
(3.7  Patch the Make\336le to Include Actions to Generate SORCERER) 108 296.67 T
(Stuff) 108 280.67 T
0 12 Q
 -0.37 (Because genmk doesn\325) 108 254 P
 -0.37 (t do this for us automatically) 217.69 254 P
 -0.37 (, we have to by hand add in the various) 352.72 254 P
(actions to the Make\336le to generate the sorcerer stuf) 108 240 T
(f.   Remember) 353.72 240 T
(, the name of the class) 421.9 240 T
 -0.36 (which you de\336ne in the sorcerer \336le is the name of the.C \336le which sorcerer spits out.) 108 226 P
 -0.36 ( I\325ve) 515.41 226 P
 -0.16 (called my sorcerer \336le \322poly_treewalk.sor\323 and it de\336nes a class called poly_manipulator) 108 212 P
 -0.16 (.) 534.16 212 P
(Therefore, I\325ll get as output a poly_manipulator) 108 198 T
(.C \336le which needs to be compiled and) 336.3 198 T
(linked in with the rest of polyanna. T) 108 184 T
(o make this work I need to make the following) 285.14 184 T
(changes to the Make\336le:) 108 170 T
(1. The SOR macro needs to be set to the directory where SORCERER is installed.) 108 144 T
 -0.1 (2. The SOR_H macro needs to be set to the directory where the SORCERER include \336les) 108 118 P
(are found.) 108 104 T
(3. The CFLAGS macro needs to include the switches -I$\050ANTLR_H\051 -I$\050SOR_H\051) 108 78 T
FMENDPAGE
%%EndPage: "5" 5
%%Page: "6" 6
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(Polyanna: A Sorcerer) 108 42.5 T
(-based Symbolic Manipulation of Polynomials) 176.71 42.5 T
(July 18, 1995) 326.05 42.5 T
(6) 536 42.5 T
0 12 Q
(4.   The SOR_SP) 108 712 T
(A) 189.24 712 T
(WN macro is set to the two \336les which SORCERER creates:) 196.94 712 T
(poly_manipulator) 108 698 T
(.C poly_manipulator) 192.67 698 T
(.h) 291.35 698 T
(5. The) 108 672 T
(SRC needs to have the following source \336les added to its list:) 141.66 672 T
(poly_grammar) 108 658 T
(.C,           poly_parser) 178 658 T
(.C, poly_manipulator) 280.99 658 T
(.C.) 382.67 658 T
 -0.29 (6. The OBJ macro needs to have the object \336les corresponding to the above added as well.) 108 632 P
(7. Actions must be added to compile the.C \336les which are output by SORCERER:) 108 606 T
1 F
(poly_manipulator) 108 580 T
(.C: poly_manipulator) 198.91 580 T
(.sor) 308.48 580 T
($\050SOR\051 -transform -CPP) 330.48 580 T
(poly_manipulator) 108 566 T
(.sor) 198.91 566 T
(poly_manipulator) 108 540 T
(.o: poly_manipulator) 198.91 540 T
(.C) 305.82 540 T
($\050CCC\051 -c $\050CFLAGS\051) 320.48 540 T
($\050SORCERER_INCLUDE\051 poly_manipulator) 108 526 T
(.c) 343.91 526 T
0 F
(This concludes the steps necessary to integrate a SORCERER manipulator into your) 108 500 T
(PCCTS-based projects. Hopefully most of this will be automated by a future version of) 108 486 T
(genmk \050hint hint T) 108 472 T
(er\051.) 197.5 472 T
1 14 Q
(3.8  How Polyanna Manipulates Polynomials.) 108 438.67 T
0 12 Q
 -0.15 (Because of space limitations, we give only a high-level overview of how Polyanna manip-) 108 412 P
(ulates polynomials. A fuller description will appear in an extended version of this paper) 108 398 T
(,) 528.79 398 T
 -0.28 (perhaps incorporated as a chapter in a future edition of the PCCTS/SORCERER reference) 108 384 P
(manual.) 108 370 T
1 14 Q
(3.9  The W) 108 336.67 T
(orkhorse Step: Adding or Multiplying two Monomials.) 172.57 336.67 T
0 12 Q
(When manipulating polynomials, the fundamental operations are adding or multiplying) 108 310 T
(two monomials. W) 108 296 T
(e consider \336rst monomial addition. If we are adding two monomials) 198.71 296 T
(which have the same variable raised to the same exponent, then we simply add their coef-) 108 282 T
(\336cients. For example, \3223 * X^2\323 plus \3224 * X^2\323 yields \3227 * X^2\323. If the monomials have) 108 268 T
(dif) 108 254 T
(ferent exponents, then the result is a polynomial with two terms.) 121.12 254 T
(Multiplying two monomials is even easier: the result is always a monomial whose coef) 108 228 T
(\336-) 525.42 228 T
(cient is the product of the coef) 108 214 T
(\336cients of the input monomials, and whose exponent of its) 253.75 214 T
 -0.25 (variable is the sum of the input exponents. Using SORCERER, it is trivial to walk the con-) 108 200 P
(structed AST) 108 186 T
(s and output a new AST which represents the results of these operations.) 170.82 186 T
1 14 Q
(3.10  Arbitrary Polynomial Multiplication/Addition) 108 152.67 T
0 12 Q
(Addition of two arbitrary polynomials is built up in two steps. The \336rst step is to create) 108 126 T
(SORCERER rules which add a monomial to an arbitrary polynomial. Second, when add-) 108 112 T
 -0.18 (ing two arbitrary polynomials, the \336rst rule is then recursively called for each of the terms) 108 98 P
(of the summand.) 108 84 T
FMENDPAGE
%%EndPage: "6" 6
%%Page: "7" 7
612 792 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
108 54 540 54 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
0 8 Q
(Polyanna: A Sorcerer) 108 42.5 T
(-based Symbolic Manipulation of Polynomials) 176.71 42.5 T
(July 18, 1995) 326.05 42.5 T
(7) 536 42.5 T
0 12 Q
(Similarly) 108 712 T
(, arbitrary polynomial multiplication is built up in a similar two-step way) 151.9 712 T
(. Rou-) 501.78 712 T
(tines are created which multiply a polynomial by a monomial. T) 108 698 T
(o multiply two polynomi-) 415.46 698 T
(als, we then call this routine many times and sum up the intermediate steps.) 108 684 T
1 14 Q
(3.1) 108 650.67 T
(1  Polynomial Differ) 124.73 650.67 T
(entiation) 245.41 650.67 T
0 12 Q
 -0.01 (Dif) 108 624 P
 -0.01 (ferentiation a monomial is trivial except for one caveat: it isn\325) 123.78 624 P
 -0.01 (t closed over the polyno-) 420.73 624 P
(mials, i.e. if the exponent of the variable is -1, then the result is not a polynomial. In this) 108 610 T
(case we report an error) 108 596 T
(, otherwise, we multiply the coef) 217.46 596 T
(\336cient by the exponent and then) 374.89 596 T
(subtract one from the exponent, i.e. \3225 * X ^2\323 yields \32210 * X\323.) 108 582 T
 -0.35 (For dif) 108 556 P
 -0.35 (ferentiation of a full polynomial, it suf) 140.43 556 P
 -0.35 (\336ces to simply traverse it dif) 322.4 556 P
 -0.35 (ferentiating each) 457.4 556 P
(term.) 108 542 T
1 16 Q
(4.0  Conclusion) 108 501.33 T
0 12 Q
 -0.07 (The use of SORCERER should be much more widespread than it currently is. A program-) 108 474 P
(mer who already knows ANTLR has already mastered 90% of the skills necessary to use) 108 460 T
(SORCERER, and after taking the plunge, will \336nd a world of new possibilities open.) 108 446 T
FMENDPAGE
%%EndPage: "7" 7
%%Trailer
%%BoundingBox: 0 0 612 792
%%PageOrder: Ascend
%%Pages: 7
%%DocumentFonts: Times-Roman
%%+ Times-Bold
%%EOF
